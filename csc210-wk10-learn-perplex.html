<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>7-Operation ALU Explorer (Universal Comparison Flags)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="color-scheme" content="only light">
  <style>
    /* Strict light theme – override any dark mode */
    html, body { background: #f9fafb; color: #181818 !important; }
    @media (prefers-color-scheme: dark) { html, body { background: #f9fafb !important; color: #181818 !important; } }
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      margin:0; padding:0;
      line-height:1.6;
      font-size:17px;
    }
    main {
      max-width:900px; margin:0 auto;
      background:#fff; box-shadow:0 8px 24px rgba(40,42,44,0.07);
      padding:2rem; border-radius:14px; margin-top:2rem; margin-bottom:2rem;
    }
    h1 { font-size:2.4rem; margin-bottom:0.25em; font-weight:800; color:#252525; }
    h2, .section-title { font-size:1.9rem; margin-top:2.1em; margin-bottom:0.4em; font-weight:700; color:#222; }
    h3 { font-size:1.4rem; margin-top:1.7em; margin-bottom:0.2em; font-weight:600; color:#264; }
    h4 { font-size:1.12rem; font-weight:500; margin-top:1em; }
    .subtitle { font-size:1.25rem; margin-bottom:1.9em; color:#666; font-weight:500;}
    ul { margin:1em 0 1.5em 1.3em; }
    li { margin-bottom:0.30em;}
    .highlight { background:#fff7e6; border-radius:5px; font-weight:600;}
    pre, code { font-family: 'Fira Mono', 'Consolas', 'Menlo', monospace; background:#f0f0f8; border-radius:7px; padding:1em;}
    pre.ascii { background:#f7fcfe; border:1px solid #cbe4fa; font-size:1rem; overflow-x:auto; }
    .section { margin-bottom:2.6em;}
    .universal-flags-badges { display:flex; gap:1.5em; margin-bottom:12px;}
    .flag-badge {
      flex:1; font-weight:700; font-size:1.16em; padding:0.7em 0.3em; border-radius:8px; text-align:center;
      color:#181800; background:linear-gradient(90deg,#ffecb3 0,#ffe0b2 100%);
      border:2px solid #fabd23; box-shadow:0 2px 14px rgba(249,191,44,0.07); margin-bottom:0.3em;
    }
    .flag-badge.active { background:linear-gradient(90deg,#ffeb3b 60%,#ffd700 100%); border-color:#e3a800;}
    .flag-badge.inactive { opacity:0.35; background:#eaeaea; border-color:#bbbbbb;}
    .decoder-viz { display:grid; grid-template-columns:repeat(8,38px); gap:7px;justify-content:center; margin:18px 0; }
    .decoder-line { width:38px; height:38px; border-radius:9px; background:#e6e6e6; display:flex; align-items:center; justify-content:center; font-size:0.92em; font-weight:600; border:2.5px solid #dedede;}
    .decoder-line.active { background:linear-gradient(90deg,#64b5f6 60%,#2962ff 100%); color:#fff; border:2.5px solid #1156e4;}
    .decoder-line.inactive { background:#eaeaea; color:#bbb;}
    .unit-table { width:100%; border-collapse:collapse; margin-bottom:22px; }
    .unit-table th, .unit-table td { border:1px solid #d3dbf7; padding:8px; background:#f5f8fe;}
    .unit-table th { background:#e3edfd; color:#2c3e50; font-weight:700;}
    .unit-table tr:nth-child(even) td { background:#eef3f6;}
    .active-unit { background:linear-gradient(90deg,#e0fff4 0,#bfffcf 100%) !important;}
    .sim-container { display:flex; gap:2rem; flex-wrap:wrap; margin:1.2em 0;}
    .sim-section { flex:1 1 260px; min-width:260px;}
    .sim-controls label { font-weight:600; margin-right:0.7em;}
    .sim-controls input { font-size:1.08em; padding:0.35em 0.7em; margin-right:0.4em; width:5.0em; border-radius:5px; border:1px solid #aaa;}
    .op-btns { display:flex; flex-wrap:wrap; gap:0.4em; margin-bottom:0.7em;}
    .op-btn {
      flex:1; cursor:pointer; padding:0.55em; font-size:1.05em; font-weight:700; border-radius:7px; border:none;
      background:#f2f8ff; color:#2962ff; margin-bottom:4px; transition:box-shadow 0.19s;
    }
    .op-btn.selected, .op-btn:focus-visible { background:linear-gradient(90deg,#42a5f5 50%,#1e88e5 100%); color:white; border:2px solid #1564f9; }
    .op-btn:disabled { background:#ffedce; color:#af7b18; border:1.5px dashed #e3a800;}
    .result-card, .flag-card { padding:0.55em 1em; border-radius:7px; background:#faf8ef; border:1.5px solid #e8ddbe; margin-bottom:0.3em; font-size:1.18em;}
    .result-card span { font-weight:700; }
    .c-out-card { padding:0.43em 0.7em; border-radius:8px; font-size:1.04em; background:#eefcf8; border:1.5px solid #c7dddc;}
    .comp-logic-box { background:linear-gradient(90deg,#ffeabf 80%,#fffed0 100%); padding:0.65em; border-radius:7px; border:1.5px solid #fabd23;}
    .zero-box { background:linear-gradient(90deg,#fdf6be 85%,#fffde4 100%); padding:0.60em; border-radius:7px; border:1.5px solid #dfd380;}
    .edu-panel { background:#f8fafe; padding:1em; border-radius:8px; margin-bottom:2em; border:1.5px solid #d2e3f7;}
    .challenge-card { background:#fffcf3; border:2px solid #ffecb3; border-radius:10px; padding:1.1em; margin-bottom:1.2em;}
    .challenge-card .hint { color:#ff9800; font-size:1.01em;}
    .challenge-card .feedback-success { color:#259b24; font-weight:700; }
    .challenge-card .feedback-error { color:#c62828; font-weight:700; }
    .quiz-card { background:#d0f3fe; border:2px solid #80c3f7; border-radius:10px; padding:1.1em; margin-bottom:1.1em;}
    .quiz-card .feedback-success { color:#2e7d32; font-weight:700;}
    .quiz-card .feedback-error { color:#b71c1c; font-weight:700;}
    .footer { text-align:center; padding:1.8em 0 1.7em 0; font-size:0.92em; color:#888;}
    .sr-only { position:absolute; left:-9999px; width:1px; height:1px; overflow:hidden;}
    @media (max-width:600px){
      main { padding:0.7rem; }
      .sim-container { flex-direction:column; gap:0.7em; }
      .op-btn { font-size:0.95em; min-width:92px;}
      h1 { font-size:1.5rem;}
      h2, .section-title { font-size:1.23rem;}
    }
  </style>
</head>
<body>
<main>
  <!-- Header Section -->
  <h1 id="main-title">7-Operation ALU Explorer</h1>
  <div class="subtitle">Universal Comparison Flags: Learn, explore, and master your ALU’s 7 operations and the powerful always-on flags</div>
  
  <!-- Section: Introduction -->
  <section class="section" id="intro">
    <h2 class="section-title">Your 7-Operation ALU: The Heart of Computation</h2>
    <h3>What Does Your ALU Actually Do?</h3>
    <p>Think of your ALU as a Swiss Army knife with exactly 7 tools. Each tool (operation) does something different, and you select which tool to use by giving the ALU a 3-bit code called an <b>operation code</b> or <b>opcode</b>. Your ALU takes in two 8-bit numbers (Input A and Input B), performs the selected operation, and produces an 8-bit result plus some helpful status flags.</p>
    <h3>The Decoder-Based Architecture</h3>
    <p>Inside your ALU, you have 7 separate functional units all computing results simultaneously:</p>
    <ul>
      <li>An <b>Adder</b> - Does 8-bit addition</li>
      <li>A <b>Shift Right Unit</b> - Shifts bits to the right</li>
      <li>A <b>Shift Left Unit</b> - Shifts bits to the left</li>
      <li>A <b>NOT Unit</b> - Inverts all bits</li>
      <li>An <b>OR Unit</b> - Bitwise OR</li>
      <li>An <b>AND Unit</b> - Bitwise AND</li>
      <li>An <b>XOR Comparator</b> - Bitwise XOR</li>
    </ul>
    <p>All seven units compute results at the same time! Only <b>one</b> result appears on the bus, controlled by a <b>3-to-8 decoder</b> and enable circuits.</p>
    <h3>How the Decoder Control Works</h3>
    <ul>
      <li>The <b>3-to-8 Decoder</b> takes the 3-bit opcode and activates exactly <b>one</b> output line.</li>
      <li>Each functional unit has an enable circuit connected to a decoder output line – only the enabled unit drives the result bus; others are disconnected.</li>
      <li>This prevents conflicts and allows modular expansion!</li>
    </ul>
    <div>
      <b>Example:</b> <code>Opcode = 101</code> (binary) → Decoder activates output line 5 → Enable circuit for AND unit goes HIGH → AND unit drives result (A &amp; B) onto output bus.
    </div>
    <h3>Your Complete Operation Table</h3>
    <pre class="ascii">
┌─────────┬────────────┬──────────┬───────────────────────────────┐
│ OpCode  │ Operation  │ Decoder  │ What It Does                  │
│         │            │ Output   │                               │
├─────────┼────────────┼──────────┼───────────────────────────────┤
│  000    │ ADD        │ Line 0   │ Output = A + B                │
│  001    │ SHR        │ Line 1   │ Output = A >> 1 (shift right) │
│  010    │ SHL        │ Line 2   │ Output = A << 1 (shift left)  │
│  011    │ NOT        │ Line 3   │ Output = ~A (bitwise invert)  │
│  100    │ OR         │ Line 4   │ Output = A | B (bitwise OR)   │
│  101    │ AND        │ Line 5   │ Output = A & B (bitwise AND)  │
│  110    │ XOR        │ Line 6   │ Output = A ^ B (bitwise XOR)  │
│  111    │ UNUSED     │ Line 7   │ DON'T USE (no unit connected!)│
└─────────┴────────────┴──────────┴───────────────────────────────┘
    </pre>
    <div class="highlight" style="margin:1.5em 0 1.3em 0;"><b>Note:</b> Opcode 111 (line 7) triggers no functional unit, leading to undefined behavior. In this design, it's intentionally unused.</div>
    <h3>Understanding the Output Flags: Universal vs. Operation-Specific</h3>
    <b>Universal Flags (work for ALL operations):</b>
    <ul>
      <li><b>Zero Flag</b> (output == 00000000): Is result zero?</li>
      <li><b>A &gt; B Flag:</b> Is Input A > Input B?</li>
      <li><b>A == B Flag:</b> Are Inputs A and B equal?</li>
    </ul>
    <b>Operation-Specific Flag:</b>
    <ul>
      <li><b>Carry-out/Shift-out Flag (c-out):</b> Carry-out for addition, shift-out for shifts, otherwise not meaningful.</li>
    </ul>
    <h3>Architecture Diagram</h3>
    <pre class="ascii" aria-label="ALU architecture diagram">
       3-bit OpCode [2:0]
              │
              ▼
        ┌───────────┐
        │  3-to-8   │
        │  Decoder  │
        └─────┬─────┘
              │
   ┌──────────┴─────────────┐
Line 0-6               Line 7
(enabled)            (unused)
   │                           │
┌──┴──┐ ...      [empty]
│ADD  │ ... 7 functional units
│En   │
└──┬──┘
   │
   ├─── ... All outputs connect to the bus
   │
   ▼
 Output Bus (8 bits)
   │
   ├─────────────────────────────┐
   │                             ▼
   ▼                        Input Comparison Logic
Zero Detection              (always running)
   │                             │
   ▼                             ▼
Zero Flag                  ┌─────┴─────┐
                          │           │
                          ▼           ▼
                      A > B Flag  A == B Flag
   (c-out flag generated per unit)
    </pre>
    <h3>Detailed Operation Descriptions</h3>
    <ul>
      <li><b>ADD (000)</b>: 8-bit addition of inputs A and B.</li>
      <li><b>Shift Right (001)</b>: Logical shift right by 1 (bit 0 falls off, bit 7→0).</li>
      <li><b>Shift Left (010)</b>: Logical shift left by 1 (bit 7 falls off, bit 0→0).</li>
      <li><b>NOT (011)</b>: Bitwise inversion of A.</li>
      <li><b>OR (100)</b>: Bitwise OR.</li>
      <li><b>AND (101)</b>: Bitwise AND.</li>
      <li><b>XOR (110)</b>: Bitwise XOR (useful for equality testing).</li>
    </ul>
    <p><b>Universal flags:</b> Zero, A&gt;B, and A==B always work for ALL operations – even for NOT, SHR, SHL, which only use A!</p>
    <h3>Why Universal Comparison Flags are Brilliant Design</h3>
    <ul>
      <li><b>Advantage 1:</b> Flexible conditional logic – perform any operation and test relationship between inputs via flags.</li>
      <li><b>Advantage 2:</b> Efficient branching – branch after any operation, no separate compare needed.</li>
      <li><b>Advantage 3:</b> No wasted cycles – comparison information is always available.</li>
      <li><b>Advantage 4:</b> Consistent architecture – all operations support comparison, simplifying programming.</li>
    </ul>
    <b>Why Decoder Architecture?</b><br>
    <ul>
      <li><b>Modular</b>: Each unit independent; easy to add more operations.</li>
      <li><b>Tri-state bus</b>: One output driver at a time; prevents conflicts.</li>
      <li><b>Always-on flag generation</b>: Comparison/zero circuits independent of decoder.</li>
    </ul>
    <b>Why These 7 Operations?</b> Arithmetic, bit manipulation, logic, comparison, and educational clarity.
  </section>
  
  <!-- Section: How to Use the Simulator -->
  <section class="section" id="howtouse">
    <h2 class="section-title">How to Use the Interactive ALU Simulator</h2>
    <h3>Getting Started</h3>
    <ul>
      <li>Set your inputs with two hexadecimal fields for A and B (try A=0x55, B=0x33 to start).</li>
      <li>Select an operation from ADD, SHR, SHL, NOT, OR, AND, XOR (opcodes 000-110).</li>
      <li>Watch the decoder visualization and see which unit is enabled.</li>
      <li>Observe all four flags: Zero, A&gt;B, A==B, c-out.</li>
      <li>Experiment freely – change inputs/operation, observe live feedback.</li>
    </ul>
    <h3>Guided Exploration Activities</h3>
    <ul>
      <li><b>Activity 1:</b> Set A=0x80, B=0x40 and try all operations; A&gt;B stays 1 throughout!</li>
      <li><b>Activity 2:</b> Set A=0x10, B=0x20; cycle operations and observe decoder activation.</li>
      <li><b>Activity 3:</b> Set A=0x42, B=0x42; Try ADD, XOR, AND – A==B=1 for all!</li>
      <li><b>Activity 4:</b> Set A=0xFF, B=0x01; use ADD; notice Zero=1, c-out=1, A&gt;B=1, A==B=0.</li>
      <li><b>Activity 5:</b> Set A=0x81, B=0x05; try SHR; c-out=1 (original bit 0).</li>
      <li><b>Activity 6:</b> A=0xAA, B=0x55; try NOT; observe A&gt;B=1 though NOT ignores B.</li>
      <li><b>Activity 7:</b> A=0xFF, B=0x0F; try AND then OR—observe decoder line activation!</li>
      <li><b>Activity 8:</b> Find equality with XOR: A=0x50, B=0x50; XOR result=0, A==B=1.</li>
      <li><b>Activity 9:</b> Swap A=0x10/B=0x80, then A=0x80/B=0x10; test A&gt;B flag in both cases.</li>
      <li><b>Activity 10:</b> There’s no button for opcode 111 (don’t use it!).</li>
      <li><b>Activity 11:</b> Rapidly change operations—observe only one active decoder line!</li>
    </ul>
    <h3>What You Should Notice</h3>
    <ul>
      <li><b>Insight 1:</b> Universal flags are <b>always active</b>.</li>
      <li><b>Insight 2:</b> Decoder ensures only one output at a time.</li>
      <li><b>Insight 3:</b> Comparison flags work for ALL operations.</li>
      <li><b>Insight 4:</b> Multiple ways to test equality (A==B, Zero with XOR).</li>
      <li><b>Insight 5:</b> c-out flag is operation-dependent.</li>
      <li><b>Insight 6:</b> Zero flag checks result; A&gt;B and A==B flags check inputs.</li>
      <li><b>Insight 7:</b> No cycles wasted—comparison is automatic every time!</li>
    </ul>
    <h3>Common Misconceptions</h3>
    <ul>
      <li><b>Don't use all 8 opcodes!</b> (Opcode 111 activates nothing.)</li>
      <li>A&gt;B/A==B flags work for ALL operations—not just XOR.</li>
      <li>Decoder just controls which output is visible—the functional units all compute in parallel.</li>
      <li>Single-input operations still provide comparison (A&gt;B, A==B).</li>
      <li>Zero flag and A==B flag measure different things.</li>
      <li>c-out meaningful only for ADD/shifts.</li>
      <li>ALU computes, CPU stores results (in registers).</li>
      <li>AND is opcode 101, OR is opcode 100—don’t mix them up!</li>
    </ul>
    <h3>Connecting to Your Project</h3>
    <p>This ALU is what you built in Week 6, uses tri-state bus concept from Week 9, and supports branching (Week 11).</p>
  </section>

  <!-- Interactive ALU Simulator Section -->
  <section class="section" id="simulator">
    <h2 class="section-title">Interactive ALU Simulator</h2>
    <p class="highlight"><b>Try out every operation, and see the universal comparison flags update in real-time!</b></p>
    <div class="sim-container" aria-label="ALU simulator">
      <div class="sim-section sim-controls" id="sim-controls">
        <label for="inputA">Input A (hex):</label>
        <input type="text" id="inputA" maxlength="4" value="55" aria-label="Input A hexadecimal" />
        <span id="inputAdec" style="font-size:0.96em; color:#579;">(Dec: 85)</span> <br>
        <span id="inputAbin" style="font-size:0.92em; color:#594;">(Bin: 01010101)</span>
        <br><br>
        <label for="inputB">Input B (hex):</label>
        <input type="text" id="inputB" maxlength="4" value="33" aria-label="Input B hexadecimal" />
        <span id="inputBdec" style="font-size:0.96em; color:#579;">(Dec: 51)</span><br>
        <span id="inputBbin" style="font-size:0.92em; color:#594;">(Bin: 00110011)</span>
        <br><br>
        <div class="op-btns" id="op-btns"></div>
        <small style="color:#8a5; font-size:0.93em;">Note: OR=100 (line 4), AND=101 (line 5).</small>
      </div>
      <div class="sim-section" id="sim-decoder-viz">
        <div class="comp-logic-box" id="comp-logic-box" tabindex="0">
          <b>Universal Comparison Logic Circuit</b><br/>
          <span style="font-size:0.95em;">Flags update instantly for all operations.<br/></span>
        </div>
        <div style="margin-top:1.0em;">
          <div class="decoder-viz" id="decoder-viz"></div>
          <small>Decoder Output Lines (Opcode controls which unit is enabled)</small>
        </div>
        <div id="unit-table-panel"></div>
      </div>
      <div class="sim-section" id="sim-results-flag">
        <div class="result-card" id="result-card"></div>
        <div class="universal-flags-badges" id="universal-flags"></div>
        <div class="c-out-card" id="sim-cout"></div>
      </div>
    </div>
    <div class="edu-panel" id="op-desc-panel"></div>
  </section>

  <!-- Challenges Section -->
  <section class="section" id="challenges">
    <h2 class="section-title">Challenge Yourself: Practice Problems</h2>
    <div id="challenge-list"></div>
  </section>

  <!-- Quiz Section -->
  <section class="section" id="quiz">
    <h2 class="section-title">Knowledge Check: Universal Flags Quiz</h2>
    <div id="quiz-list"></div>
    <div id="quiz-score-panel" style="font-size:1.13em; margin-top:0.8em;"></div>
  </section>

  <!-- Educational Notes -->
  <section class="section" id="edu-notes">
    <h2 class="section-title">Key Takeaways & Course Connections</h2>
    <ul>
      <li><b>Zero, A&gt;B, and A==B flags:</b> Always available, always meaningful—even for single-input ops</li>
      <li><b>Decoder controls which unit's output appears—but all units compute in parallel.</b></li>
      <li><b>Comparison flags separate from functional units—you get input comparison for free!</b></li>
      <li><b>Efficient CPU design:</b> No cycles wasted on separate compare instructions—use flags for branching, decision logic.</li>
      <li><b>Practical Assembly Coding:</b> Write programs using ALU ops, always test input relationship via flags.</li>
      <li>ALU integrates with register file (Week 9), control unit (Week 11), and full CPU project.</li>
    </ul>
  </section>

  <!-- Footer -->
  <div class="footer">
    <b>Navigation — use Tab/Shift+Tab to reach buttons and inputs. Number keys 0-6 select operations.</b><br>
    &copy; 2025 Computer Systems Learning Platform. ADA accessible. All content in this guide is strictly aligned to CPU/ALU architecture curriculum.<br>
  </div>
</main>

<script>
/* --- Embedded Data Model (from Section 4 JSON) --- */
const operations=[
  {opcode:"000",decoderLine:0,name:"ADD",symbol:"+",description:"Adds Input A and Input B together (8-bit addition). Decoder activates line 0 to enable ADD unit.",inputsUsed:["A","B"],flagsValid:{zero:true,aGreaterB:true,aEqualsB:true,cout:true,coutMeaning:"carry-out (unsigned overflow)"},universalFlagsNote:"Zero, A>B, and A==B work for this operation (as they do for ALL operations)",implementation:"result = (inputA + inputB) & 0xFF; cout = (inputA + inputB) > 0xFF; zero = result === 0; aGreaterB = inputA > inputB; aEqualsB = inputA === inputB",examples:[{A:"0x55",B:"0x33",result:"0x88",zero:false,cout:false,aGreaterB:true,aEqualsB:false},{A:"0xFF",B:"0x01",result:"0x00",zero:true,cout:true,aGreaterB:true,aEqualsB:false},{A:"0x80",B:"0x80",result:"0x00",zero:true,cout:true,aGreaterB:false,aEqualsB:true}]},
  {opcode:"001",decoderLine:1,name:"SHR",symbol:">>",description:"Shifts Input A right by 1 bit (bit 0 falls off, bit 7 becomes 0). Decoder activates line 1 to enable SHR unit.",inputsUsed:["A"],flagsValid:{zero:true,aGreaterB:true,aEqualsB:true,cout:true,coutMeaning:"shift-out (original bit 0)"},universalFlagsNote:"A>B and A==B compare inputs even though SHR only uses Input A",implementation:"cout = inputA & 1; result = inputA >> 1; zero = result === 0; aGreaterB = inputA > inputB; aEqualsB = inputA === inputB",examples:[{A:"0x55",B:"0x10",result:"0x2A",zero:false,cout:true,aGreaterB:true,aEqualsB:false},{A:"0x01",B:"0x01",result:"0x00",zero:true,cout:true,aGreaterB:false,aEqualsB:true},{A:"0x80",B:"0xFF",result:"0x40",zero:false,cout:false,aGreaterB:false,aEqualsB:false}]},
  {opcode:"010",decoderLine:2,name:"SHL",symbol:"<<",description:"Shifts Input A left by 1 bit (bit 7 falls off, bit 0 becomes 0). Decoder activates line 2 to enable SHL unit.",inputsUsed:["A"],flagsValid:{zero:true,aGreaterB:true,aEqualsB:true,cout:true,coutMeaning:"shift-out (original bit 7)"},universalFlagsNote:"A>B and A==B compare inputs even though SHL only uses Input A",implementation:"cout = (inputA & 0x80) >> 7; result = (inputA << 1) & 0xFF; zero = result === 0; aGreaterB = inputA > inputB; aEqualsB = inputA === inputB",examples:[{A:"0x55",B:"0x30",result:"0xAA",zero:false,cout:false,aGreaterB:true,aEqualsB:false},{A:"0x80",B:"0x80",result:"0x00",zero:true,cout:true,aGreaterB:false,aEqualsB:true},{A:"0x01",B:"0x10",result:"0x02",zero:false,cout:false,aGreaterB:false,aEqualsB:false}]},
  {opcode:"011",decoderLine:3,name:"NOT",symbol:"~",description:"Inverts all bits of Input A (0→1, 1→0). Decoder activates line 3 to enable NOT unit.",inputsUsed:["A"],flagsValid:{zero:true,aGreaterB:true,aEqualsB:true,cout:false,coutMeaning:"not meaningful (cleared)"},universalFlagsNote:"A>B and A==B compare inputs even though NOT only uses Input A",implementation:"result = (~inputA) & 0xFF; cout = 0; zero = result === 0; aGreaterB = inputA > inputB; aEqualsB = inputA === inputB",examples:[{A:"0x55",B:"0x10",result:"0xAA",zero:false,cout:false,aGreaterB:true,aEqualsB:false},{A:"0xFF",B:"0xFF",result:"0x00",zero:true,cout:false,aGreaterB:false,aEqualsB:true},{A:"0x00",B:"0x80",result:"0xFF",zero:false,cout:false,aGreaterB:false,aEqualsB:false}]},
  {opcode:"100",decoderLine:4,name:"OR",symbol:"|",description:"Bitwise OR of Input A and Input B (either can be 1 for result 1). Decoder activates line 4 to enable OR unit.",inputsUsed:["A","B"],flagsValid:{zero:true,aGreaterB:true,aEqualsB:true,cout:false,coutMeaning:"not meaningful (cleared)"},universalFlagsNote:"Zero, A>B, and A==B work for this operation (as they do for ALL operations)",implementation:"result = inputA | inputB; cout = 0; zero = result === 0; aGreaterB = inputA > inputB; aEqualsB = inputA === inputB",examples:[{A:"0x55",B:"0x33",result:"0x77",zero:false,cout:false,aGreaterB:true,aEqualsB:false},{A:"0x00",B:"0x00",result:"0x00",zero:true,cout:false,aGreaterB:false,aEqualsB:true},{A:"0x0F",B:"0xF0",result:"0xFF",zero:false,cout:false,aGreaterB:false,aEqualsB:false}]},
  {opcode:"101",decoderLine:5,name:"AND",symbol:"&",description:"Bitwise AND of Input A and Input B (both must be 1 for result 1). Decoder activates line 5 to enable AND unit.",inputsUsed:["A","B"],flagsValid:{zero:true,aGreaterB:true,aEqualsB:true,cout:false,coutMeaning:"not meaningful (cleared)"},universalFlagsNote:"Zero, A>B, and A==B work for this operation (as they do for ALL operations)",implementation:"result = inputA & inputB; cout = 0; zero = result === 0; aGreaterB = inputA > inputB; aEqualsB = inputA === inputB",examples:[{A:"0x55",B:"0x33",result:"0x11",zero:false,cout:false,aGreaterB:true,aEqualsB:false},{A:"0xFF",B:"0x00",result:"0x00",zero:true,cout:false,aGreaterB:true,aEqualsB:false},{A:"0xF0",B:"0xF0",result:"0xF0",zero:false,cout:false,aGreaterB:false,aEqualsB:true}]},
  {opcode:"110",decoderLine:6,name:"XOR",symbol:"^",description:"Bitwise XOR of Input A and Input B. Decoder activates line 6 to enable XOR unit. Note: A>B and A==B flags work here too (as with all operations)!",inputsUsed:["A","B"],flagsValid:{zero:true,aGreaterB:true,aEqualsB:true,cout:false,coutMeaning:"not meaningful (cleared)"},universalFlagsNote:"XOR is useful for equality testing: result=0x00 when A==B, which also sets Zero flag. But A>B and A==B flags work independently!",implementation:"result = inputA ^ inputB; cout = 0; zero = result === 0; aGreaterB = inputA > inputB; aEqualsB = inputA === inputB",examples:[{A:"0x55",B:"0x33",result:"0x66",zero:false,cout:false,aGreaterB:true,aEqualsB:false},{A:"0xFF",B:"0xFF",result:"0x00",zero:true,cout:false,aGreaterB:false,aEqualsB:true},{A:"0x10",B:"0x20",result:"0x30",zero:false,cout:false,aGreaterB:false,aEqualsB:false}]}
];
const challengeScenarios=[
  {title:"Universal Flags Test",description:"Set A=0x80, B=0x40 and try THREE different operations. Verify A>B=1 for all of them.",hint:"The comparison flags are universal - they work regardless of which operation you select!",solution:{verifyAllOps:true,A:"0x80",B:"0x40",expectedAGreaterB:true}},
  {title:"Equality Multiple Ways",description:"Set both inputs to 0x42. Use XOR to see BOTH Zero=1 (result) AND A==B=1 (inputs).",hint:"XOR gives you two ways to detect equality: Zero flag and A==B flag!",solution:{opcode:"110",decoderLine:6,A:"0x42",B:"0x42",expectedResult:"0x00",expectedZero:true,expectedAEqualsB:true}},
  {title:"Single-Input Operation Comparison",description:"Use NOT with A=0xFF, B=0x01. Notice A>B flag still shows comparison even though NOT ignores B!",hint:"Comparison logic is separate from functional units. It always compares inputs.",solution:{opcode:"011",decoderLine:3,A:"0xFF",B:"0x01",expectedResult:"0x00",expectedAGreaterB:true}},
  {title:"Clear Lower Nibble with Comparison",description:"Clear bits 0-3 of A=0xAC using B=0xF0. What's A>B flag?",hint:"Use AND (line 5). Then check: is 172 > 240? No! So A>B=0.",solution:{opcode:"101",decoderLine:5,A:"0xAC",B:"0xF0",expectedResult:"0xA0",expectedAGreaterB:false}},
  {title:"Zero Result vs Equal Inputs",description:"Find inputs where result is zero BUT inputs are not equal. Try ADD.",hint:"A=0xFF, B=0x01 gives result 0x00 (overflow), but A≠B!",solution:{opcode:"000",decoderLine:0,A:"0xFF",B:"0x01",expectedResult:"0x00",expectedZero:true,expectedAEqualsB:false}},
  {title:"Shift with Magnitude Check",description:"Shift A=0x20 left and simultaneously verify A>B where B=0x10.",hint:"SHL (line 2) gives you shifted result AND comparison flags showing A>B=1.",solution:{opcode:"010",decoderLine:2,A:"0x20",B:"0x10",expectedResult:"0x40",expectedAGreaterB:true}}
];
const quizQuestions=[
  {question:"Which flags work for ALL operations in this ALU?",options:["Only the Zero flag","Zero, A>B, and A==B flags","All four flags including c-out","Only c-out flag"],correct:1,explanation:"Zero, A>B, and A==B are universal flags generated by always-on circuitry. They work for every operation. Only c-out is operation-specific."},
  {question:"If you perform a NOT operation with A=0x50, B=0x30, will the A>B flag be valid?",options:["No, because NOT only uses Input A","Yes, comparison logic always monitors both inputs","Only if you use XOR instead","The flag will be undefined"],correct:1,explanation:"A>B and A==B are universal flags that always compare inputs, regardless of which operation is selected or whether that operation uses both inputs."},
  {question:"What's the difference between the Zero flag and the A==B flag?",options:["They are the same thing","Zero checks result, A==B checks inputs","Zero works for all ops, A==B only for XOR","A==B is more accurate"],correct:1,explanation:"Zero flag checks if the RESULT (output) is 0x00. A==B flag checks if the INPUTS are equal. Very different! Example: ADD with A=B=0x42 gives result=0x84 (Zero=0) but A==B=1."},
  {question:"Why is the XOR operation particularly useful for equality testing?",options:["It's the only operation that sets the A==B flag","XOR result is 0x00 when inputs equal, giving two indicators (Zero and A==B)","XOR is faster than other operations","XOR automatically branches on equality"],correct:1,explanation:"XOR gives you TWO ways to detect equality: (1) A==B flag (like all operations), and (2) Zero flag will be set because XOR of equal values is 0x00. Both confirm equality!"},
  {question:"What generates the A>B and A==B flags?",options:["The currently enabled functional unit","The 3-to-8 decoder","Separate always-on comparison circuitry","The XOR unit exclusively"],correct:2,explanation:"A>B and A==B are generated by dedicated comparison circuitry that always monitors inputs A and B, completely independent of which functional unit is enabled."},
  {question:"If decoder line 5 (AND) is active with A=0xFF, B=0xFF, what will A==B flag show?",options:["0 (false)","1 (true)","Undefined because AND doesn't support comparison","Same as the Zero flag"],correct:1,explanation:"A==B will be 1 because the inputs are equal (0xFF == 0xFF). This flag works for ALL operations, including AND. The AND result (0xFF) and Zero flag (0) are separate from the input comparison."},
  {question:"Which flag's meaning changes depending on the selected operation?",options:["Zero flag","A>B flag","A==B flag","c-out flag"],correct:3,explanation:"The c-out flag is operation-specific: carry-out for ADD, shift-out for shifts, not meaningful for logic ops. The three universal flags (Zero, A>B, A==B) always have the same meaning."},
  {question:"Can you determine if A>B after performing a shift left operation?",options:["No, shifts don't provide comparison information","Only if you use a separate compare instruction first","Yes, the A>B flag always shows input comparison","Only if both inputs are used by the operation"],correct:2,explanation:"Yes! The A>B flag is universal and always compares inputs, regardless of operation. Even though SHL only uses Input A for the shift, the comparison logic still compares A and B."},
  {question:"What advantage do universal comparison flags provide?",options:["Faster operation execution","Smaller chip size","No need for separate comparison instructions - every operation provides comparison info","Easier decoder design"],correct:2,explanation:"Universal flags mean you never waste cycles on separate comparison instructions. Every operation automatically tells you about input relationships (A>B, A==B) and result (Zero). This is a major efficiency win!"}
];

// Universal flag rendering colors
const flagColors={zero:"#ffe600",aGreaterB:"#F68F50",aEqualsB:"#42e27b"};
const decoderColors=["#297ffe","#24cca3","#fdcd3a","#cfd165","#ffb547","#ff6e44","#886cfb","#bbb"];

// Simulator state
let simState={
  inputA:0x55,inputB:0x33,opIndex:0
};

function hexParse(val){ // returns number from hex-string; only 0-FF allowed
  val=(val||"").replace(/[^a-fA-F0-9]/g,"");
  if(!val) return 0;
  let n=parseInt(val,16);
  if(isNaN(n)||n<0) return 0;
  if(n>0xFF) return 255;
  return n;
}
function hexFormat(n){ return "0x"+("00"+n.toString(16).toUpperCase()).slice(-2);}
function binFormat(n,bits=8){ let s=n.toString(2); return "0".repeat(bits-s.length)+s;}
function decFormat(n){ return n.toString(10);}
function opForIndex(idx){ return operations[idx]; }

// Renderers
function renderOpBtns(){
  const el=document.getElementById("op-btns");
  el.innerHTML="";
  for(let i=0;i<operations.length;i++){
    let op=operations[i];
    let btn=document.createElement("button");
    btn.type="button";
    btn.className="op-btn"+(simState.opIndex===i?" selected":"");
    btn.setAttribute("aria-label",`${op.name} (${op.symbol}), opcode ${op.opcode}`);
    btn.tabIndex=0;
    btn.textContent=op.name+" ("+op.symbol+")";
    btn.onclick=()=>{simState.opIndex=i; updateSimulator();}
    el.appendChild(btn);
  }
  // Disabled button for unused opcode 111
  let btn=document.createElement("button");
  btn.type="button"; btn.className="op-btn"; btn.textContent="UNUSED (opcode 111)"; btn.disabled=true;
  btn.setAttribute("aria-label","opcode 111 button not active");
  el.appendChild(btn);
}
// KEYBOARD shortcut support
document.addEventListener("keydown",e=>{
  if(document.activeElement.tagName==="INPUT") return;
  if(e.key>="0"&&e.key<="6"){ simState.opIndex=+e.key; updateSimulator(); }
});

function renderDecoderViz(){
  let el=document.getElementById("decoder-viz");
  el.innerHTML="";
  for(let i=0;i<8;i++){
    let line=document.createElement("div");
    line.className="decoder-line"+(simState.opIndex===i?" active":" inactive");
    line.textContent=i;
    if(simState.opIndex===i)line.setAttribute("aria-label","active decoder line");
    el.appendChild(line);
  }
}
// Render results and flags
function updateSimulator(){
  simState.inputA=hexParse(document.getElementById("inputA").value);
  simState.inputB=hexParse(document.getElementById("inputB").value);

  let op=opForIndex(simState.opIndex);
  let A=simState.inputA,B=simState.inputB;
  let result,zero,aGreaterB,aEqualsB,cout;
  switch(op.opcode){
    case "000": result=(A+B)&0xFF; cout=((A+B)>0xFF)?1:0; break;
    case "001": result=(A>>1); cout=(A&1)?1:0; break;
    case "010": result=(A<<1)&0xFF; cout=(A&0x80)?1:0; break;
    case "011": result=(~A)&0xFF; cout=0; break;
    case "100": result=(A|B); cout=0; break;
    case "101": result=(A&B); cout=0; break;
    case "110": result=(A^B); cout=0; break;
    default: result=0; cout=0;
  }
  zero=(result===0);
  aGreaterB=(A>B);
  aEqualsB=(A===B);

  // Update input field displays
  document.getElementById("inputAdec").textContent="(Dec: "+decFormat(A)+")";
  document.getElementById("inputAbin").textContent="(Bin: "+binFormat(A)+")";
  document.getElementById("inputBdec").textContent="(Dec: "+decFormat(B)+")";
  document.getElementById("inputBbin").textContent="(Bin: "+binFormat(B)+")";

  // Results
  document.getElementById("result-card").innerHTML=
    "<span>Result:</span> "+
    "<b>"+hexFormat(result)+"</b> "+
    "(Bin: "+binFormat(result)+", Dec: "+result+")<br>"+
    "<b>Active Decoder Line:</b> "+op.decoderLine;

  // Universal Flags
  let uf=document.getElementById("universal-flags");
  uf.innerHTML="";
  let flagArr=[
    {id:"zero",name:"Zero",val:zero},
    {id:"aGreaterB",name:"A > B",val:aGreaterB},
    {id:"aEqualsB",name:"A == B",val:aEqualsB}
  ];
  flagArr.forEach(f=>{
    let b=document.createElement("div");
    b.className="flag-badge"+(f.val?" active":" inactive");
    b.textContent=f.name+": "+(f.val?"1":"0");
    b.style.borderColor=flagColors[f.id];
    b.setAttribute("tabIndex",0);
    uf.appendChild(b);
  });

  // c-out
  let coutPanel=document.getElementById("sim-cout");
  coutPanel.innerHTML="<b>Operation-Specific Flag</b><br/>";
  coutPanel.innerHTML+="<span>C-out: "+cout+"</span> ";
  coutPanel.innerHTML+="<span style='font-size:0.98em; color:#37a;'>("+op.flagsValid.coutMeaning+")</span>";

  // Highlight comp logic boxes
  document.getElementById("comp-logic-box").style.boxShadow="0 4px 32px rgba(253,226,46,"+(aEqualsB?0.14:0.09)+")";

  // Decoder visualization
  renderDecoderViz();

  // Functional unit table
  renderUnitTable();

  // Operation description
  let descPanel=document.getElementById("op-desc-panel");
  descPanel.innerHTML="<b>"+op.name+" ("+op.symbol+")</b>: "+op.description+"<br>"+
    "<b>Inputs Used:</b> "+op.inputsUsed.join(", ")+"<br>"+
    "<b>Flags Valid:</b> "+
    (op.flagsValid.zero?"Zero, ":"")+
    (op.flagsValid.aGreaterB?"A>B, ":"")+
    (op.flagsValid.aEqualsB?"A==B, ":"")+
    (op.flagsValid.cout?"C-out":"")+
    "<br><span style='font-size:1em; color:#f68f50;'>"+op.universalFlagsNote+"</span>";
}
// Render functional unit table under decoder
function renderUnitTable(){
  let el=document.getElementById("unit-table-panel");
  let html="<table class='unit-table'><thead><tr><th>Decoder Line</th><th>Operation</th><th>Inputs Used</th><th>Description</th></tr></thead><tbody>";
  for(let i=0;i<operations.length;i++){
    let op=operations[i];
    html+="<tr"+(simState.opIndex===i?" class='active-unit'":"")+"><td>"+op.decoderLine+"</td><td>"+op.name+" ("+op.symbol+")</td><td>"+op.inputsUsed.join(", ")+"</td><td>"+op.description+"</td></tr>";
  }
  html+="<tr><td>7</td><td>UNUSED</td><td>-</td><td>Don't use!</td></tr>";
  html+="</tbody></table>";
  el.innerHTML=html;
}
//init sim
function initSimulator(){
  document.getElementById("inputA").addEventListener("input",()=>{updateSimulator();});
  document.getElementById("inputB").addEventListener("input",()=>{updateSimulator();});
  renderOpBtns(); 
  updateSimulator();
}

// Challenges
function renderChallenges(){
  let el=document.getElementById("challenge-list");
  el.innerHTML="";
  challengeScenarios.forEach((c,i)=>{
    let card=document.createElement("div");
    card.className="challenge-card";
    card.innerHTML="<b>"+c.title+"</b><br>"+
      c.description+"<br><i class='hint'>Hint: "+c.hint+"</i><br>";
    let btn=document.createElement("button");
    btn.type="button"; btn.className="op-btn";
    btn.textContent="Try This";
    btn.onclick=()=>runChallenge(i,card);
    card.appendChild(btn);
    let feedback=document.createElement("div");
    feedback.className="challenge-feedback";
    card.appendChild(feedback);
    el.appendChild(card);
  })
}
function runChallenge(i,card){
  let c=challengeScenarios[i];
  // Apply test scenario
  document.getElementById("inputA").value=c.solution.A.replace(/0x/i,"");
  document.getElementById("inputB").value=c.solution.B.replace(/0x/i,"");
  let opIdx=operations.findIndex(op=>op.opcode===c.solution.opcode);
  if (opIdx<0) opIdx=simState.opIndex;
  simState.opIndex=(typeof opIdx!=="undefined"?opIdx:0);
  updateSimulator();
  // Validate challenge
  let A=hexParse(c.solution.A), B=hexParse(c.solution.B);
  let op=operations[(typeof c.solution.opcode!=="undefined"?opIdx:simState.opIndex)];
  let result, zero, aGreaterB, aEqualsB, cout;
  switch(op.opcode){
    case "000": result=(A+B)&0xFF; cout=((A+B)>0xFF)?1:0; break;
    case "001": result=(A>>1); cout=(A&1)?1:0; break;
    case "010": result=(A<<1)&0xFF; cout=(A&0x80)?1:0; break;
    case "011": result=(~A)&0xFF; cout=0; break;
    case "100": result=(A|B); cout=0; break;
    case "101": result=(A&B); cout=0; break;
    case "110": result=(A^B); cout=0; break;
    default: result=0; cout=0;
  }
  zero=(result===0);
  aGreaterB=(A>B);
  aEqualsB=(A===B);
  // Feedback
  let feedback=card.querySelector(".challenge-feedback");
  let ok=true;
  if ("expectedAGreaterB" in c.solution)
    ok &= (aGreaterB===c.solution.expectedAGreaterB);
  if ("expectedZero" in c.solution)
    ok &= (zero===c.solution.expectedZero);
  if ("expectedAEqualsB" in c.solution)
    ok &= (aEqualsB===c.solution.expectedAEqualsB);
  if ("expectedResult" in c.solution)
    ok &= (hexFormat(result)===c.solution.expectedResult);

  feedback.innerHTML= ok?
    "<span class='feedback-success'>✔ Well done! Scenario meets learning objective.</span>":"<span class='feedback-error'>✘ Not quite! Try again/Review expected output.</span>";
};

// Quiz rendering
let quizProgress={score:0,total:quizQuestions.length,answered:0};
function renderQuiz(){
  let el=document.getElementById("quiz-list");
  el.innerHTML="";
  quizQuestions.forEach((q,i)=>{
    let card=document.createElement("div");
    card.className="quiz-card";
    card.innerHTML="<b>"+q.question+"</b><br>";
    q.options.forEach((opt,optIdx)=>{
      let btn=document.createElement("button");
      btn.type="button"; btn.className="op-btn";
      btn.textContent=opt;
      btn.onclick=()=>runQuiz(i,optIdx,card,btn);
      btn.tabIndex=0;
      card.appendChild(btn);
    });
    let feedback=document.createElement("div");
    feedback.className="quiz-feedback";
    card.appendChild(feedback);
    el.appendChild(card);
  })
}
function runQuiz(idx,selectedIdx,card,btn){
  let q=quizQuestions[idx];
  btn.blur(); // remove focus
  let correct=(selectedIdx===q.correct);
  let feedback=card.querySelector(".quiz-feedback");
  feedback.innerHTML=correct?
    "<span class='feedback-success'>✔ Correct!</span> <span style='font-size:0.99em;'>"+q.explanation+"</span>":
    "<span class='feedback-error'>✘ Not correct!</span> <span style='font-size:0.99em;'>"+q.explanation+"</span>";
  if(q._tried) return; // only score first attempt
  q._tried=true;
  quizProgress.answered++; if(correct) quizProgress.score++;
  updateQuizScore();
}
function updateQuizScore(){
  document.getElementById("quiz-score-panel").innerHTML=
    "Quiz Complete: "+quizProgress.answered+" / "+quizProgress.total+" answered. Score: <b>"+quizProgress.score+"</b> correct.";
}

// Initialization
initSimulator();
renderChallenges();
renderQuiz();
updateQuizScore();

</script>
</body>
</html>
