<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSC210 - Week 4: Sequential Logic & Memory</title>
    <style>
        /* General Styling & Accessibility */
        :root {
            --primary-bg: #ffffff;
            --primary-text: #1a1a1a;
            --accent-color: #0056b3;
            --accent-hover: #004494;
            --border-color: #dcdcdc;
            --header-bg: #f8f9fa;
            --code-bg: #e9ecef;
            --success-color: #28a745;
            --warning-color: #ffc107;
            --danger-color: #dc3545;
            --light-text: #6c757d;
            --logic-high: #28a745;
            --logic-low: #6c757d;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            background-color: var(--primary-bg);
            color: var(--primary-text);
        }

        /* Responsive Layout */
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header and Navigation */
        header {
            background-color: var(--header-bg);
            padding: 1rem 0;
            border-bottom: 1px solid var(--border-color);
            text-align: center;
        }

        header h1 {
            margin: 0;
            font-size: 2.5rem;
            color: var(--accent-color);
        }

        nav {
            background-color: #f1f1f1;
            padding: 10px 0;
            position: sticky;
            top: 0;
            z-index: 100;
            border-bottom: 1px solid var(--border-color);
        }

        nav ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
        }

        nav ul li a {
            padding: 10px 15px;
            text-decoration: none;
            color: var(--accent-color);
            font-weight: bold;
            display: block;
        }
        nav ul li a:hover, nav ul li a:focus {
            background-color: var(--border-color);
            border-radius: 5px;
        }

        /* Main Content Sections */
        h2 {
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 10px;
            margin-top: 40px;
            color: var(--primary-text);
        }

        h3 {
            color: var(--accent-color);
            margin-top: 30px;
        }

        p, li {
            font-size: 1.1rem;
        }

        hr {
            margin: 40px 0;
            border: 0;
            border-top: 1px solid var(--border-color);
        }

        /* Interactive Elements Styling */
        .interactive-box {
            border: 2px solid var(--border-color);
            padding: 20px;
            margin-top: 20px;
            border-radius: 8px;
            background-color: #fdfdfd;
        }

        .interactive-box h4 {
            margin-top: 0;
        }
        
        .circuit-diagram-svg {
            display: block;
            margin: 20px auto;
            max-width: 500px;
            width: 100%;
            height: auto;
        }
        
        /* SVG Diagram Styling */
        .circuit-diagram-svg .gate {
            fill: none;
            stroke: var(--primary-text);
            stroke-width: 2;
        }
        .circuit-diagram-svg .wire {
            fill: none;
            stroke-width: 2;
            transition: stroke 0.3s ease;
        }
        .circuit-diagram-svg .label {
            font-family: "Courier New", Courier, monospace;
            font-size: 20px;
            font-weight: bold;
            transition: fill 0.3s ease;
        }
        .circuit-diagram-svg .high {
            stroke: var(--logic-high);
            fill: var(--logic-high);
        }
        .circuit-diagram-svg .low {
            stroke: var(--logic-low);
            fill: var(--logic-low);
        }

        .led {
            display: inline-block;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid #333;
            background-color: #888;
            transition: background-color 0.2s;
            margin: 0 10px;
            vertical-align: middle;
        }

        .led.on {
            background-color: var(--success-color);
            box-shadow: 0 0 10px var(--success-color);
        }

        button, .button {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            margin: 5px;
            transition: background-color 0.2s;
        }

        button:hover, .button:hover {
            background-color: var(--accent-hover);
        }
        
        button.reset {
             background-color: var(--danger-color);
        }
        
        .toggle-button {
            padding: 8px 15px;
        }
        
        .toggle-button.active {
            background-color: var(--danger-color); /* Active low is "active" */
        }

        /* ADA Compliance & Privacy */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
        
        .privacy-notice {
            text-align: center;
            color: var(--light-text);
            font-style: italic;
            padding: 20px;
            border-top: 1px solid var(--border-color);
        }

        .info-box {
            background-color: #e7f3fe;
            border-left: 6px solid #2196F3;
            padding: 15px;
            margin: 20px 0;
        }
        
        .info-box strong {
             color: #1a252f;
        }

        /* Register and RAM styling */
        .register-bits, .ram-grid {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
        }
        .bit, .ram-cell {
            width: 40px;
            height: 40px;
            border: 1px solid var(--border-color);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-family: "Courier New", monospace;
            background-color: #fff;
        }
        
        .ram-cell.selected {
            background-color: #fffbe6;
            border-color: var(--warning-color);
        }
        
        input[type="text"] {
            font-family: "Courier New", monospace;
            padding: 8px;
            font-size: 1rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

    </style>
</head>
<body>

    <header>
        <div class="container">
            <h1>CSC210 Week 4</h1>
            <p>From Combinational Logic to Sequential Logic & Memory</p>
        </div>
    </header>

    <nav>
        <ul>
            <li><a href="#part1">Part 1: Intro</a></li>
            <li><a href="#part2">Part 2: Latches</a></li>
            <li><a href="#part3">Part 3: Registers</a></li>
            <li><a href="#part4">Part 4: RAM</a></li>
            <li><a href="#quiz">Quiz</a></li>
            <li><a href="#references">References</a></li>
        </ul>
    </nav>

    <main class="container">

        <section id="part1" aria-labelledby="part1-heading">
            <h2 id="part1-heading">Part 1: Introduction to Sequential Logic</h2>
            <p>Welcome! This week, we transition from circuits that just calculate (combinational) to circuits that can **remember** (sequential). The key ingredient is the **feedback loop**, where a circuit's output is fed back into its own input, creating a state.</p>

            <h3>Combinational vs. Sequential Logic</h3>
            <ul>
                <li><strong>Combinational:</strong> The output depends *only* on the current inputs. Think of a simple calculator; 2 + 2 will always be 4.</li>
                <li><strong>Sequential:</strong> The output depends on the current inputs *and* the circuit's past state. It has memory.</li>
            </ul>

            <div class="interactive-box">
                <h4>Analogy: Light Switch vs. Toggle Button</h4>
                <p>A simple light switch is **combinational**. Its state (up/down) directly determines if the light is on or off. A TV power button is **sequential**. You press the same button to turn it on (if it's off) and to turn it off (if it's on). The button's action depends on the TV's current state.</p>
                <button id="toggle-button" class="toggle-button" aria-pressed="false">TV Power Button</button>
                <div style="display: inline-block; vertical-align: middle;">
                    <span>TV Status: </span>
                    <div id="tv-led" class="led"></div>
                    <span id="tv-status" class="sr-only">Off</span>
                </div>
            </div>
            
            <div class="info-box">
                <strong>Key Insight:</strong> The simple act of connecting NAND gates (or NOR gates) in a cross-coupled loop creates a 1-bit memory element, the foundation of all computer memory.
            </div>
        </section>

        <hr>

        <section id="part2" aria-labelledby="part2-heading">
            <h2 id="part2-heading">Part 2: Building Memory from Gates - The Latch</h2>
            <p>The most fundamental memory element is the **latch**. We can build one using just two NAND gates in a feedback loop. This is called an **S'R' Latch** (Set-Reset Latch with active-low inputs).</p>
            
            <h3>Interactive S'R' Latch (from NAND Gates)</h3>
            <p>This latch has two inputs, S' (Set-not) and R' (Reset-not), and two outputs, Q and Q'. Because it's built from NAND gates, the inputs are **active-low**. This means you activate a signal by setting its input to 0, not 1.</p>
            <ul>
                <li><strong>Hold (S'=1, R'=1):</strong> This is the inactive, "remembering" state. The latch holds its previous value.</li>
                <li><strong>Set (S'=0, R'=1):</strong> The active-low S' input forces the output Q to 1.</li>
                <li><strong>Reset (S'=1, R'=0):</strong> The active-low R' input forces the output Q to 0.</li>
                <li><strong>Invalid (S'=0, R'=0):</strong> Activating both inputs at once forces both Q and Q' to 1, which breaks the rule that they must be opposites.</li>
            </ul>

            <div class="interactive-box">
                <h4>S'R' Latch Simulator</h4>
                
                <!-- SVG Diagram -->
                <svg viewBox="0 0 500 250" class="circuit-diagram-svg" aria-label="S'R' Latch Diagram">
                    <!-- Top NAND Gate -->
                    <path d="M150,50 H200 A50,50 0 0 1 200,100 H150 Z" class="gate"/>
                    <circle cx="255" cy="75" r="5" fill="var(--primary-text)"/>
                    
                    <!-- Bottom NAND Gate -->
                    <path d="M150,150 H200 A50,50 0 0 1 200,200 H150 Z" class="gate"/>
                    <circle cx="255" cy="175" r="5" fill="var(--primary-text)"/>

                    <!-- Wires and Labels -->
                    <!-- Inputs -->
                    <line id="s-wire-in" x1="50" y1="60" x2="150" y2="60" class="wire low"/>
                    <text id="s-label" x="30" y="65" class="label low">S'</text>
                    
                    <line id="r-wire-in" x1="50" y1="190" x2="150" y2="190" class="wire high"/>
                    <text id="r-label" x="30" y="195" class="label high">R'</text>

                    <!-- Outputs -->
                    <line id="q-not-wire-out" x1="260" y1="75" x2="360" y2="75" class="wire high"/>
                    <text id="q-not-label" x="370" y="80" class="label high">Q'</text>

                    <line id="q-wire-out" x1="260" y1="175" x2="360" y2="175" class="wire low"/>
                    <text id="q-label" x="370" y="180" class="label low">Q</text>

                    <!-- Feedback Loops -->
                    <polyline id="feedback-q" points="320,175 320,160 140,160 140,90 150,90" class="wire low"/>
                    <polyline id="feedback-q-not" points="320,75 320,90 140,90 140,140 150,140" class="wire high"/>
                </svg>

                <div style="text-align: center; margin-top: 20px;">
                    <button id="sr-s-button" class="toggle-button" aria-pressed="false">S' = 1</button>
                    <button id="sr-r-button" class="toggle-button" aria-pressed="false">R' = 1</button>
                </div>
                <div style="text-align: center; margin-top: 15px;">
                    <strong>Q:</strong><div id="sr-q-led" class="led"></div>
                    <strong>Q':</strong><div id="sr-qn-led" class="led"></div>
                </div>
                <div id="sr-status" style="text-align:center; font-weight: bold; margin-top:10px; height: 20px;" aria-live="polite">
                    State: Hold
                </div>
            </div>

            <div class="interactive-box">
                <h4>Example: Gated S-R Latch in Logisim</h4>
                <p>The basic S'R' latch is always "listening" to its inputs. To control *when* it can change state, we can add two more NAND gates and an "Enable" input. This creates a <strong>Gated S-R Latch</strong>. The latch will only respond to the Set and Reset inputs when the Enable signal is high (1). The image below shows this configuration in Logisim 2.7.1.</p>
                <img src="images/S-R-latch-logisim.png" alt="Gated S-R Latch circuit built in Logisim using four NAND gates" style="max-width: 100%; height: auto; border: 1px solid var(--border-color); border-radius: 5px; margin-top: 10px;">
            </div>

            <div class="info-box">
                <h4>A Note on Startup Dynamics & Race Conditions</h4>
                <p>You might notice in a simulator like Logisim that when the simulation starts, the latch outputs flicker between red (error/indeterminate) and random states. This is because a real-world latch has no defined state at power-on. Both gates "race" to determine the output based on tiny physical imperfections. Eventually, one "wins" and the circuit settles into a stable, but random, state (either Q=0 or Q=1). This is why most sequential systems include a global **reset signal** to force all memory elements into a known starting state.</p>
            </div>
        </section>

        <hr>
        
        <section id="part3" aria-labelledby="part3-heading">
            <h2 id="part3-heading">Part 3: Registers and Clocked Systems</h2>
            <p>A single latch holds one bit. To store a byte (8 bits), we need eight memory elements working together. A **register** is a group of flip-flops (an improved, clock-controlled latch) that store multiple bits in parallel. To ensure all bits are updated at the exact same time, we use a common **clock signal**.</p>
            
            <h3>Interactive 4-Bit Register</h3>
            <p>This register uses D Flip-Flops. Data is only loaded from the input when the **Load/Enable** signal is high (1) and the **Clock** transitions from low to high (a "rising edge"). The **Clear** signal asynchronously resets all bits to 0.</p>

            <div class="interactive-box">
                <h4>4-Bit Register Simulator</h4>
                <!-- Data Inputs -->
                <div>
                    <strong>Data Input (D):</strong>
                    <input type="text" id="reg-input" maxlength="4" value="1010" pattern="[01]{4}" title="Enter a 4-bit binary value">
                </div>
                <!-- Control Signals -->
                <div style="margin-top: 15px;">
                    <strong>Controls:</strong>
                    <button id="reg-load-button" class="toggle-button" aria-pressed="false">Load Enable = 0</button>
                    <button id="reg-clear-button" class="reset">Clear</button>
                </div>
                <!-- Clock Signal -->
                <div style="margin-top: 15px;">
                    <strong>Clock:</strong>
                    <button id="reg-clock-button">Pulse Clock ( rising edge)</button>
                </div>
                <!-- Register Output -->
                <div style="margin-top: 20px;">
                    <strong>Register Stored Value (Q):</strong>
                    <div class="register-bits" id="register-q-output" aria-label="Register output">
                        <div class="bit" aria-label="Bit 3">0</div>
                        <div class="bit" aria-label="Bit 2">0</div>
                        <div class="bit" aria-label="Bit 1">0</div>
                        <div class="bit" aria-label="Bit 0">0</div>
                    </div>
                </div>
                <div id="reg-status" style="text-align:center; font-style: italic; color: var(--light-text); height: 20px;" aria-live="polite">
                    Register holding state.
                </div>
            </div>
        </section>

        <hr>
        
        <section id="part4" aria-labelledby="part4-heading">
            <h2 id="part4-heading">Part 4: Introduction to RAM</h2>
            <p>How do we go from an 8-bit register to the kilobytes or gigabytes of RAM in a computer? By arranging our memory cells in a grid and using an **address decoder** to select which specific location (or "word") we want to read from or write to.</p>
            
            <h3>Simplified RAM Model (8 words x 4 bits)</h3>
            <p>This model has 8 memory locations (addresses 000 through 111). Each location stores a 4-bit word.</p>
            <ul>
                <li><strong>Memory Address Register (MAR):</strong> Holds the address of the location to be accessed.</li>
                <li><strong>Memory Data Register (MDR):</strong> Holds the data to be written or the data that was just read.</li>
                <li><strong>Control Signals:</strong> A Read/Write signal determines the operation.</li>
            </ul>

            <div class="interactive-box">
                <h4>Interactive 8x4 RAM</h4>
                <div style="display: flex; flex-wrap: wrap; gap: 20px; justify-content: space-between;">
                    <!-- Controls -->
                    <div style="flex-basis: 300px;">
                        <strong>Controls:</strong><br>
                        Address (3-bit): <input type="text" id="ram-address" maxlength="3" value="000" pattern="[01]{3}"><br>
                        Data (4-bit): <input type="text" id="ram-data-in" maxlength="4" value="1100" pattern="[01]{4}"><br><br>
                        <button id="ram-read-btn">Read from Address</button>
                        <button id="ram-write-btn">Write to Address</button>
                    </div>
                    <!-- Data Bus -->
                    <div style="flex-basis: 300px;">
                        <strong>Data Bus (MDR):</strong>
                        <div id="ram-data-out" class="register-bits" style="background-color: var(--code-bg); padding: 5px; border-radius: 4px;">
                            <div class="bit">-</div><div class="bit">-</div><div class="bit">-</div><div class="bit">-</div>
                        </div>
                        <div id="ram-status" aria-live="polite" style="text-align: center; margin-top: 10px; height: 20px;">Ready</div>
                    </div>
                </div>
                 <!-- RAM Grid -->
                <div style="margin-top: 20px;">
                    <strong>RAM Memory Cells:</strong>
                    <div id="ram-grid-container" class="ram-grid" style="display: grid; grid-template-columns: auto 1fr; gap: 5px;">
                        <!-- Generated by JS -->
                    </div>
                </div>
            </div>

        </section>

        <hr>
        
        <section id="quiz" aria-labelledby="quiz-heading">
            <h2 id="quiz-heading">Check Your Understanding</h2>
            <p>Test your knowledge of this week's key concepts.</p>
            <div class="interactive-box">
                <form id="quiz-form">
                    <div class="quiz-question">
                        <p><strong>1. A circuit's output depends on both its current inputs and its previous state. This describes a:</strong></p>
                        <label><input type="radio" name="q1" value="a"> Combinational circuit</label><br>
                        <label><input type="radio" name="q1" value="b"> Sequential circuit</label><br>
                        <label><input type="radio" name="q1" value="c"> Arithmetic Logic Unit</label>
                        <div id="q1-feedback"></div>
                    </div>
                    <div class="quiz-question" style="margin-top: 20px;">
                        <p><strong>2. In a standard S'R' latch built from NAND gates, what is the hold state?</strong></p>
                        <label><input type="radio" name="q2" value="a"> S'=0, R'=0</label><br>
                        <label><input type="radio" name="q2" value="b"> S'=0, R'=1</label><br>
                        <label><input type="radio" name="q2" value="c"> S'=1, R'=1</label>
                        <div id="q2-feedback"></div>
                    </div>
                    <div class="quiz-question" style="margin-top: 20px;">
                        <p><strong>3. What is the primary purpose of a clock signal in a multi-bit register?</strong></p>
                        <label><input type="radio" name="q3" value="a"> To provide power to the flip-flops</label><br>
                        <label><input type="radio" name="q3" value="b"> To synchronize the state change of all bits</label><br>
                        <label><input type="radio" name="q3" value="c"> To clear the register to zero</label>
                        <div id="q3-feedback"></div>
                    </div>
                    <button type="submit" style="margin-top: 20px;">Submit Answers</button>
                </form>
                <div id="quiz-results" style="margin-top: 20px; font-weight: bold;"></div>
            </div>
        </section>
        
        <hr>

        <section id="references" aria-labelledby="references-heading">
            <h2 id="references-heading">References and Further Reading</h2>
            <ul style="list-style-type: none; padding-left: 0;">
                <li style="margin-bottom: 10px;">
                    Scott, J. C. (2009). <em>But How Do It Know? - The Basic Principles of Computers for Everyone</em>. A valuable, simplified introduction to the core concepts of computer operation.
                </li>
                <li>
                    Harris, D. M., & Harris, S. L. (2012). <em>Digital Design and Computer Architecture</em>. Morgan Kaufmann. A comprehensive textbook for a deeper dive into digital logic and computer architecture.
                </li>
            </ul>
        </section>

    </main>
    
    <footer>
         <p class="privacy-notice">Privacy Notice: This is a self-contained educational tool. No data is tracked or stored. All interactions are limited to your current session.</p>
    </footer>

    <script>
    document.addEventListener('DOMContentLoaded', function() {

        // --- Part 1: TV Toggle Button ---
        const toggleButton = document.getElementById('toggle-button');
        const tvLed = document.getElementById('tv-led');
        const tvStatus = document.getElementById('tv-status');
        let isTvOn = false;

        toggleButton.addEventListener('click', () => {
            isTvOn = !isTvOn;
            if (isTvOn) {
                tvLed.classList.add('on');
                tvStatus.textContent = 'On';
                toggleButton.setAttribute('aria-pressed', 'true');
            } else {
                tvLed.classList.remove('on');
                tvStatus.textContent = 'Off';
                toggleButton.setAttribute('aria-pressed', 'false');
            }
        });

        // --- Part 2: S'R' NAND Latch Simulator ---
        const sButton = document.getElementById('sr-s-button');
        const rButton = document.getElementById('sr-r-button');
        const qLed = document.getElementById('sr-q-led');
        const qnLed = document.getElementById('sr-qn-led');
        const srStatus = document.getElementById('sr-status');
        
        // SVG Elements
        const sWireIn = document.getElementById('s-wire-in');
        const sLabel = document.getElementById('s-label');
        const rWireIn = document.getElementById('r-wire-in');
        const rLabel = document.getElementById('r-label');
        const qWireOut = document.getElementById('q-wire-out');
        const qLabel = document.getElementById('q-label');
        const qNotWireOut = document.getElementById('q-not-wire-out');
        const qNotLabel = document.getElementById('q-not-label');
        const feedbackQ = document.getElementById('feedback-q');
        const feedbackQNot = document.getElementById('feedback-q-not');

        // S'R' Latch is active low, so initial state is 1,1 (Hold)
        let s_not = 1;
        let r_not = 1;
        let q = 0; // Start in a known reset state
        let qn = 1;

        function updateSrLatch() {
            // NAND Gate Logic Simulation
            // We loop a few times to allow the feedback to stabilize
            for (let i = 0; i < 5; i++) {
                qn = (s_not && q) ? 0 : 1; // Top gate
                q = (r_not && qn) ? 0 : 1; // Bottom gate
            }
            
            // Update LEDs
            qLed.classList.toggle('on', q === 1);
            qnLed.classList.toggle('on', qn === 1);

            // Update Status Text
            if (s_not === 0 && r_not === 0) {
                srStatus.textContent = 'State: Invalid!';
                srStatus.style.color = 'var(--danger-color)';
            } else if (s_not === 0 && r_not === 1) {
                srStatus.textContent = 'State: Set';
                srStatus.style.color = 'var(--primary-text)';
            } else if (s_not === 1 && r_not === 0) {
                srStatus.textContent = 'State: Reset';
                srStatus.style.color = 'var(--primary-text)';
            } else { // s_not=1, r_not=1
                srStatus.textContent = 'State: Hold';
                srStatus.style.color = 'var(--primary-text)';
            }
            
            // Update SVG Diagram
            updateSvgClass(sWireIn, s_not);
            updateSvgClass(sLabel, s_not);
            updateSvgClass(rWireIn, r_not);
            updateSvgClass(rLabel, r_not);
            updateSvgClass(qWireOut, q);
            updateSvgClass(qLabel, q);
            updateSvgClass(qNotWireOut, qn);
            updateSvgClass(qNotLabel, qn);
            updateSvgClass(feedbackQ, q);
            updateSvgClass(feedbackQNot, qn);
        }
        
        function updateSvgClass(element, state) {
            element.classList.remove('high', 'low');
            element.classList.add(state === 1 ? 'high' : 'low');
        }
        
        sButton.addEventListener('click', () => {
            s_not = 1 - s_not; // toggle 0/1
            sButton.textContent = `S' = ${s_not}`;
            sButton.classList.toggle('active', s_not === 0);
            sButton.setAttribute('aria-pressed', s_not === 0);
            updateSrLatch();
        });
        
        rButton.addEventListener('click', () => {
            r_not = 1 - r_not; // toggle 0/1
            rButton.textContent = `R' = ${r_not}`;
            rButton.classList.toggle('active', r_not === 0);
            rButton.setAttribute('aria-pressed', r_not === 0);
            updateSrLatch();
        });

        // Initialize
        updateSrLatch();

        // --- Part 3: Register Simulator ---
        const regInput = document.getElementById('reg-input');
        const loadButton = document.getElementById('reg-load-button');
        const clearButton = document.getElementById('reg-clear-button');
        const clockButton = document.getElementById('reg-clock-button');
        const regOutputBits = document.querySelectorAll('#register-q-output .bit');
        const regStatus = document.getElementById('reg-status');

        let registerValue = [0, 0, 0, 0];
        let loadEnabled = false;

        function updateRegisterDisplay() {
            registerValue.forEach((bit, index) => {
                regOutputBits[index].textContent = bit;
            });
        }

        loadButton.addEventListener('click', () => {
            loadEnabled = !loadEnabled;
            loadButton.classList.toggle('active', loadEnabled);
            loadButton.textContent = `Load Enable = ${loadEnabled ? 1 : 0}`;
            loadButton.setAttribute('aria-pressed', loadEnabled);
        });

        clearButton.addEventListener('click', () => {
            registerValue = [0, 0, 0, 0];
            updateRegisterDisplay();
            regStatus.textContent = "Register cleared.";
        });
        
        clockButton.addEventListener('click', () => {
            if (loadEnabled) {
                const inputValue = regInput.value.padStart(4, '0');
                if (/^[01]{4}$/.test(inputValue)) {
                    registerValue = inputValue.split('').map(Number);
                    updateRegisterDisplay();
                    regStatus.textContent = `Loaded value ${inputValue} on clock pulse.`;
                } else {
                    regStatus.textContent = "Invalid input. Use 4 binary digits.";
                }
            } else {
                regStatus.textContent = "Clock pulsed, but Load was disabled. Holding state.";
            }
        });

        // --- Part 4: RAM Simulator ---
        const ramAddressInput = document.getElementById('ram-address');
        const ramDataInInput = document.getElementById('ram-data-in');
        const readBtn = document.getElementById('ram-read-btn');
        const writeBtn = document.getElementById('ram-write-btn');
        const dataOutBits = document.querySelectorAll('#ram-data-out .bit');
        const ramStatus = document.getElementById('ram-status');
        const ramGridContainer = document.getElementById('ram-grid-container');

        let ram = Array(8).fill(null).map(() => Array(4).fill(0));

        function createRamGrid() {
            ramGridContainer.innerHTML = ''; // Clear existing
            for (let i = 0; i < 8; i++) {
                const addressLabel = document.createElement('div');
                addressLabel.textContent = i.toString(2).padStart(3, '0');
                addressLabel.style.textAlign = 'right';
                addressLabel.style.fontFamily = '"Courier New", monospace';
                
                const row = document.createElement('div');
                row.classList.add('register-bits');
                row.dataset.address = i;

                for (let j = 0; j < 4; j++) {
                    const cell = document.createElement('div');
                    cell.classList.add('ram-cell');
                    cell.textContent = ram[i][j];
                    row.appendChild(cell);
                }
                ramGridContainer.appendChild(addressLabel);
                ramGridContainer.appendChild(row);
            }
        }
        
        function updateRamSelection(address) {
            document.querySelectorAll('.ram-grid .register-bits .ram-cell').forEach(cell => cell.classList.remove('selected'));
            if (address >= 0 && address < 8) {
                const selectedRow = document.querySelector(`.ram-grid .register-bits[data-address='${address}']`);
                if(selectedRow) {
                    selectedRow.querySelectorAll('.ram-cell').forEach(cell => cell.classList.add('selected'));
                }
            }
        }
        
        ramAddressInput.addEventListener('input', () => {
             const addr = parseInt(ramAddressInput.value, 2);
             if(!isNaN(addr)) updateRamSelection(addr);
        });

        writeBtn.addEventListener('click', () => {
            const addr = parseInt(ramAddressInput.value, 2);
            const data = ramDataInInput.value;
            if (isNaN(addr) || addr < 0 || addr > 7 || !/^[01]{4}$/.test(data)) {
                ramStatus.textContent = "Invalid address or data.";
                return;
            }
            ram[addr] = data.split('').map(Number);
            createRamGrid(); // Redraw grid with new data
            updateRamSelection(addr);
            ramStatus.textContent = `Wrote ${data} to address ${addr.toString(2).padStart(3, '0')}.`;
        });
        
        readBtn.addEventListener('click', () => {
            const addr = parseInt(ramAddressInput.value, 2);
            if (isNaN(addr) || addr < 0 || addr > 7) {
                ramStatus.textContent = "Invalid address.";
                return;
            }
            const data = ram[addr];
            data.forEach((bit, index) => {
                dataOutBits[index].textContent = bit;
            });
            updateRamSelection(addr);
            ramStatus.textContent = `Read ${data.join('')} from address ${addr.toString(2).padStart(3, '0')}.`;
        });

        // Initial RAM setup
        createRamGrid();

        // --- Quiz Section ---
        const quizForm = document.getElementById('quiz-form');
        const quizResults = document.getElementById('quiz-results');
        
        quizForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const answers = {
                q1: document.querySelector('input[name="q1"]:checked')?.value,
                q2: document.querySelector('input[name="q2"]:checked')?.value,
                q3: document.querySelector('input[name="q3"]:checked')?.value
            };
            
            const correctAnswers = { q1: 'b', q2: 'c', q3: 'b' };
            const feedback = {
                q1: "The correct answer is <strong>b) Sequential circuit</strong>. A sequential circuit's output depends on its past state (memory), while a combinational circuit's output depends only on its current inputs.",
                q2: "The correct answer is <strong>c) S'=1, R'=1</strong>. In a NAND-based S'R' latch, the inputs are active-low. Setting both to the inactive high state (1) causes the latch to hold its value.",
                q3: "The correct answer is <strong>b) To synchronize the state change of all bits</strong>. A clock pulse ensures all flip-flops in a register update at the exact same moment for coherent data storage."
            };

            let score = 0;
            const q1Feedback = document.getElementById('q1-feedback');
            const q2Feedback = document.getElementById('q2-feedback');
            const q3Feedback = document.getElementById('q3-feedback');

            // Clear previous feedback
            q1Feedback.innerHTML = '';
            q2Feedback.innerHTML = '';
            q3Feedback.innerHTML = '';

            // Question 1
            if (answers.q1 === correctAnswers.q1) {
                score++;
                q1Feedback.innerHTML = `<p style="color: var(--success-color); margin-top: 10px;"><strong>Correct!</strong></p>`;
            } else {
                q1Feedback.innerHTML = `<p style="color: var(--danger-color); margin-top: 10px;"><strong>Incorrect.</strong> ${feedback.q1}</p>`;
            }

            // Question 2
            if (answers.q2 === correctAnswers.q2) {
                score++;
                q2Feedback.innerHTML = `<p style="color: var(--success-color); margin-top: 10px;"><strong>Correct!</strong></p>`;
            } else {
                q2Feedback.innerHTML = `<p style="color: var(--danger-color); margin-top: 10px;"><strong>Incorrect.</strong> ${feedback.q2}</p>`;
            }

            // Question 3
            if (answers.q3 === correctAnswers.q3) {
                score++;
                q3Feedback.innerHTML = `<p style="color: var(--success-color); margin-top: 10px;"><strong>Correct!</strong></p>`;
            } else {
                q3Feedback.innerHTML = `<p style="color: var(--danger-color); margin-top: 10px;"><strong>Incorrect.</strong> ${feedback.q3}</p>`;
            }

            quizResults.textContent = `You scored ${score} out of 3.`;
             if(score === 3) {
                quizResults.style.color = 'var(--success-color)';
            } else {
                 quizResults.style.color = 'var(--danger-color)';
            }
        });
    });
    </script>
</body>
</html>


