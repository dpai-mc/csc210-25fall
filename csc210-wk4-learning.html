<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSC210 - Week 4: Sequential Logic & Memory</title>
    <style>
        /* General Styling & Accessibility */
        :root {
            --primary-bg: #ffffff;
            --primary-text: #1a1a1a;
            --accent-color: #0056b3;
            --accent-hover: #004494;
            --border-color: #dcdcdc;
            --header-bg: #f8f9fa;
            --code-bg: #e9ecef;
            --success-color: #28a745;
            --warning-color: #ffc107;
            --danger-color: #dc3545;
            --light-text: #6c757d;
            --logic-high: #28a745;
            --logic-low: #6c757d;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            background-color: var(--primary-bg);
            color: var(--primary-text);
        }

        /* Responsive Layout */
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header and Navigation */
        header {
            background-color: var(--header-bg);
            padding: 1rem 0;
            border-bottom: 1px solid var(--border-color);
            text-align: center;
        }

        header h1 {
            margin: 0;
            font-size: 2.5rem;
            color: var(--accent-color);
        }

        nav {
            background-color: #f1f1f1;
            padding: 10px 0;
            position: sticky;
            top: 0;
            z-index: 100;
            border-bottom: 1px solid var(--border-color);
        }

        nav ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
        }

        nav ul li a {
            padding: 10px 15px;
            text-decoration: none;
            color: var(--accent-color);
            font-weight: bold;
            display: block;
        }
        nav ul li a:hover, nav ul li a:focus {
            background-color: var(--border-color);
            border-radius: 5px;
        }

        /* Main Content Sections */
        h2 {
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 10px;
            margin-top: 40px;
            color: var(--primary-text);
        }

        h3 {
            color: var(--accent-color);
            margin-top: 30px;
        }

        p, li {
            font-size: 1.1rem;
        }

        hr {
            margin: 40px 0;
            border: 0;
            border-top: 1px solid var(--border-color);
        }

        /* Interactive Elements Styling */
        .interactive-box {
            border: 2px solid var(--border-color);
            padding: 20px;
            margin-top: 20px;
            border-radius: 8px;
            background-color: #fdfdfd;
        }

        .interactive-box h4 {
            margin-top: 0;
        }
        
        .circuit-diagram-svg {
            display: block;
            margin: 20px auto;
            max-width: 500px;
            width: 100%;
            height: auto;
        }
        
        /* SVG Diagram Styling */
        .circuit-diagram-svg .gate {
            fill: none;
            stroke: var(--primary-text);
            stroke-width: 2;
        }
        .circuit-diagram-svg .wire {
            fill: none;
            stroke-width: 2;
            transition: stroke 0.3s ease;
        }
        .circuit-diagram-svg .label {
            font-family: "Courier New", Courier, monospace;
            font-size: 20px;
            font-weight: bold;
            transition: fill 0.3s ease;
        }
        .circuit-diagram-svg .high {
            stroke: var(--logic-high);
            fill: var(--logic-high);
        }
        .circuit-diagram-svg .low {
            stroke: var(--logic-low);
            fill: var(--logic-low);
        }

        .led {
            display: inline-block;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid #333;
            background-color: #888;
            transition: background-color 0.2s;
            margin: 0 10px;
            vertical-align: middle;
        }

        .led.on {
            background-color: var(--success-color);
            box-shadow: 0 0 10px var(--success-color);
        }

        button, .button {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            margin: 5px;
            transition: background-color 0.2s;
        }

        button:hover, .button:hover {
            background-color: var(--accent-hover);
        }
        
        button.reset {
             background-color: var(--danger-color);
        }
        
        .toggle-button {
            padding: 8px 15px;
        }
        
        .toggle-button.active {
            background-color: var(--danger-color); /* Active low is "active" */
        }

        /* Video & Transcript Section */
        .video-container {
            position: relative;
            padding-bottom: 56.25%; /* 16:9 aspect ratio */
            height: 0;
            overflow: hidden;
            max-width: 100%;
            background: #e9ecef;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
        }

        .video-container iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .transcript-container details {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-top: 20px;
        }

        .transcript-container summary {
            padding: 15px;
            font-weight: bold;
            cursor: pointer;
            background-color: var(--header-bg);
            border-radius: 7px;
            outline-offset: 5px;
        }
        
        .transcript-container details[open] summary {
            border-bottom: 1px solid var(--border-color);
            border-radius: 7px 7px 0 0;
        }

        .transcript-container summary:hover,
        .transcript-container summary:focus {
            background-color: var(--border-color);
        }

        .transcript-content {
            padding: 15px;
            background-color: #fdfdfd;
            border-radius: 0 0 7px 7px;
            max-height: 400px;
            overflow-y: auto;
        }
        .transcript-content p {
            margin: 0 0 10px 0;
        }
        .transcript-content p strong {
            color: var(--accent-color);
        }


        /* ADA Compliance & Privacy */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
        
        .privacy-notice {
            text-align: center;
            color: var(--light-text);
            font-style: italic;
            padding: 20px;
            border-top: 1px solid var(--border-color);
        }

        .info-box {
            background-color: #e7f3fe;
            border-left: 6px solid #2196F3;
            padding: 15px;
            margin: 20px 0;
        }
        
        .info-box strong {
             color: #1a252f;
        }

        /* Register and RAM styling */
        .register-bits, .ram-grid {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
        }
        .bit, .ram-cell {
            width: 40px;
            height: 40px;
            border: 1px solid var(--border-color);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-family: "Courier New", monospace;
            background-color: #fff;
        }
        
        .ram-cell.selected {
            background-color: #fffbe6;
            border-color: var(--warning-color);
        }
        
        input[type="text"] {
            font-family: "Courier New", monospace;
            padding: 8px;
            font-size: 1rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

    </style>
</head>
<body>

    <header>
        <div class="container">
            <h1>CSC210 Week 4</h1>
            <p>From Combinational Logic to Sequential Logic & Memory</p>
        </div>
    </header>

    <nav>
        <ul>
            <li><a href="#summary-review">Summary</a></li>
            <li><a href="#part1">Part 1: Intro</a></li>
            <li><a href="#part2">Part 2: Latches</a></li>
            <li><a href="#part3">Part 3: Registers</a></li>
            <li><a href="#part4">Part 4: RAM</a></li>
            <li><a href="#quiz">Quiz</a></li>
            <li><a href="#references">References</a></li>
        </ul>
    </nav>

    <main class="container">

        <section id="summary-review" aria-labelledby="summary-heading">
            <h2 id="summary-heading">Week 4 Summary & Review</h2>
            <p>Watch the video below for a summary of this week's key topics, from the concept of feedback loops to the structure of RAM.</p>
            
            <!-- Responsive Video Embed -->
            <div class="video-container">
                <iframe 
                    src="https://www.youtube.com/embed/D0cOMld4w_U?si=itq-BypX2CyP0hx4" 
                    title="YouTube video player: CSC210 Week 4 Summary" 
                    frameborder="0" 
                    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" 
                    allowfullscreen>
                </iframe>
            </div>

            <!-- Accessible Transcript -->
            <div class="transcript-container">
                <details>
                    <summary>View Video Transcript</summary>
                    <div class="transcript-content" id="transcript-content-box">
                        <!-- Transcript will be loaded here by JavaScript -->
                    </div>
                </details>
            </div>
        </section>

        <hr>

        <section id="part1" aria-labelledby="part1-heading">
            <h2 id="part1-heading">Part 1: Introduction to Sequential Logic</h2>
            <p>Welcome! This week, we transition from circuits that just calculate (combinational) to circuits that can **remember** (sequential). The key ingredient is the **feedback loop**, where a circuit's output is fed back into its own input, creating a state.</p>

            <h3>Combinational vs. Sequential Logic</h3>
            <ul>
                <li><strong>Combinational:</strong> The output depends *only* on the current inputs. Think of a simple calculator; 2 + 2 will always be 4.</li>
                <li><strong>Sequential:</strong> The output depends on the current inputs *and* the circuit's past state. It has memory.</li>
            </ul>

            <div class="interactive-box">
                <h4>Analogy: Light Switch vs. Toggle Button</h4>
                <p>A simple light switch is **combinational**. Its state (up/down) directly determines if the light is on or off. A TV power button is **sequential**. You press the same button to turn it on (if it's off) and to turn it off (if it's on). The button's action depends on the TV's current state.</p>
                <button id="toggle-button" class="toggle-button" aria-pressed="false">TV Power Button</button>
                <div style="display: inline-block; vertical-align: middle;">
                    <span>TV Status: </span>
                    <div id="tv-led" class="led"></div>
                    <span id="tv-status" class="sr-only">Off</span>
                </div>
            </div>
            
            <div class="info-box">
                <strong>Key Insight:</strong> The simple act of connecting NAND gates (or NOR gates) in a cross-coupled loop creates a 1-bit memory element, the foundation of all computer memory.
            </div>
        </section>

        <hr>

        <section id="part2" aria-labelledby="part2-heading">
            <h2 id="part2-heading">Part 2: Building Memory from Gates - The Latch</h2>
            <p>The most fundamental memory element is the **latch**. We can build one using just two NAND gates in a feedback loop. This is called an **S'R' Latch** (Set-Reset Latch with active-low inputs).</p>
            
            <h3>Interactive S'R' Latch (from NAND Gates)</h3>
            <p>This latch has two inputs, S' (Set-not) and R' (Reset-not), and two outputs, Q and Q'. Because it's built from NAND gates, the inputs are **active-low**. This means you activate a signal by setting its input to 0, not 1.</p>
            <ul>
                <li><strong>Hold (S'=1, R'=1):</strong> This is the inactive, "remembering" state. The latch holds its previous value.</li>
                <li><strong>Set (S'=0, R'=1):</strong> The active-low S' input forces the output Q to 1.</li>
                <li><strong>Reset (S'=1, R'=0):</strong> The active-low R' input forces the output Q to 0.</li>
                <li><strong>Invalid (S'=0, R'=0):</strong> Activating both inputs at once forces both Q and Q' to 1, which breaks the rule that they must be opposites.</li>
            </ul>

            <div class="interactive-box">
                <h4>S'R' Latch Simulator</h4>
                
                <!-- SVG Diagram -->
                <svg viewBox="0 0 500 250" class="circuit-diagram-svg" aria-label="S'R' Latch Diagram">
                    <!-- Top NAND Gate -->
                    <path d="M150,50 H200 A50,50 0 0 1 200,100 H150 Z" class="gate"/>
                    <circle cx="255" cy="75" r="5" fill="var(--primary-text)"/>
                    
                    <!-- Bottom NAND Gate -->
                    <path d="M150,150 H200 A50,50 0 0 1 200,200 H150 Z" class="gate"/>
                    <circle cx="255" cy="175" r="5" fill="var(--primary-text)"/>

                    <!-- Wires and Labels -->
                    <!-- Inputs -->
                    <line id="s-wire-in" x1="50" y1="60" x2="150" y2="60" class="wire low"/>
                    <text id="s-label" x="30" y="65" class="label low">S'</text>
                    
                    <line id="r-wire-in" x1="50" y1="190" x2="150" y2="190" class="wire high"/>
                    <text id="r-label" x="30" y="195" class="label high">R'</text>

                    <!-- Outputs -->
                    <line id="q-not-wire-out" x1="260" y1="75" x2="360" y2="75" class="wire high"/>
                    <text id="q-not-label" x="370" y="80" class="label high">Q'</text>

                    <line id="q-wire-out" x1="260" y1="175" x2="360" y2="175" class="wire low"/>
                    <text id="q-label" x="370" y="180" class="label low">Q</text>

                    <!-- Feedback Loops -->
                    <polyline id="feedback-q" points="320,175 320,160 140,160 140,90 150,90" class="wire low"/>
                    <polyline id="feedback-q-not" points="320,75 320,90 140,90 140,140 150,140" class="wire high"/>
                </svg>

                <div style="text-align: center; margin-top: 20px;">
                    <button id="sr-s-button" class="toggle-button" aria-pressed="false">S' = 1</button>
                    <button id="sr-r-button" class="toggle-button" aria-pressed="false">R' = 1</button>
                </div>
                <div style="text-align: center; margin-top: 15px;">
                    <strong>Q:</strong><div id="sr-q-led" class="led"></div>
                    <strong>Q':</strong><div id="sr-qn-led" class="led"></div>
                </div>
                <div id="sr-status" style="text-align:center; font-weight: bold; margin-top:10px; height: 20px;" aria-live="polite">
                    State: Hold
                </div>
            </div>

            <div class="interactive-box">
                <h4>Example: Gated S-R Latch in Logisim</h4>
                <p>In Logisim, when we create our S-R latch, we have 2 inputs that we will call "In" and "Set" where the "In" bit is the value to be stored in this memory bit and the "Set" allows us to change what is stored in this bit. We only care about the Q output which is what is stored so we truncate the wire to Q' since it is not needed.</p>
                <img src="images/S-R-latch-logisim.png" alt="Gated S-R Latch circuit built in Logisim using four NAND gates" style="max-width: 100%; height: auto; border: 1px solid var(--border-color); border-radius: 5px; margin-top: 10px;">
            </div>

            <div class="info-box">
                <h4>A Note on Startup Dynamics & Race Conditions</h4>
                <p>You might notice in a simulator like Logisim that when the simulation starts, the latch outputs flicker between red (error/indeterminate) and random states. This is because a real-world latch has no defined state at power-on. Both gates "race" to determine the output based on tiny physical imperfections. Eventually, one "wins" and the circuit settles into a stable, but random, state (either Q=0 or Q=1). This is why most sequential systems include a global **reset signal** to force all memory elements into a known starting state.</p>
            </div>
        </section>

        <hr>
        
        <section id="part3" aria-labelledby="part3-heading">
            <h2 id="part3-heading">Part 3: Registers and Clocked Systems</h2>
            <p>A single latch holds one bit. To store a byte (8 bits), we need eight memory elements working together. A **register** is a group of flip-flops (an improved, clock-controlled latch) that store multiple bits in parallel. To ensure all bits are updated at the exact same time, we use a common **clock signal**.</p>
            
            <h3>Interactive 4-Bit Register</h3>
            <p>This register uses D Flip-Flops. Data is only loaded from the input when the **Load/Enable** signal is high (1) and the **Clock** transitions from low to high (a "rising edge"). The **Clear** signal asynchronously resets all bits to 0.</p>

            <div class="interactive-box">
                <h4>4-Bit Register Simulator</h4>
                <!-- Data Inputs -->
                <div>
                    <strong>Data Input (D):</strong>
                    <input type="text" id="reg-input" maxlength="4" value="1010" pattern="[01]{4}" title="Enter a 4-bit binary value">
                </div>
                <!-- Control Signals -->
                <div style="margin-top: 15px;">
                    <strong>Controls:</strong>
                    <button id="reg-load-button" class="toggle-button" aria-pressed="false">Load Enable = 0</button>
                    <button id="reg-clear-button" class="reset">Clear</button>
                </div>
                <!-- Clock Signal -->
                <div style="margin-top: 15px;">
                    <strong>Clock:</strong>
                    <button id="reg-clock-button">Pulse Clock ( rising edge)</button>
                </div>
                <!-- Register Output -->
                <div style="margin-top: 20px;">
                    <strong>Register Stored Value (Q):</strong>
                    <div class="register-bits" id="register-q-output" aria-label="Register output">
                        <div class="bit" aria-label="Bit 3">0</div>
                        <div class="bit" aria-label="Bit 2">0</div>
                        <div class="bit" aria-label="Bit 1">0</div>
                        <div class="bit" aria-label="Bit 0">0</div>
                    </div>
                </div>
                <div id="reg-status" style="text-align:center; font-style: italic; color: var(--light-text); height: 20px;" aria-live="polite">
                    Register holding state.
                </div>
            </div>
        </section>

        <hr>
        
        <section id="part4" aria-labelledby="part4-heading">
            <h2 id="part4-heading">Part 4: Introduction to RAM</h2>
            <p>How do we go from an 8-bit register to the kilobytes or gigabytes of RAM in a computer? By arranging our memory cells in a grid and using an **address decoder** to select which specific location (or "word") we want to read from or write to.</p>
            
            <h3>Simplified RAM Model (8 words x 4 bits)</h3>
            <p>This model has 8 memory locations (addresses 000 through 111). Each location stores a 4-bit word.</p>
            <ul>
                <li><strong>Memory Address Register (MAR):</strong> Holds the address of the location to be accessed.</li>
                <li><strong>Memory Data Register (MDR):</strong> Holds the data to be written or the data that was just read.</li>
                <li><strong>Control Signals:</strong> A Read/Write signal determines the operation.</li>
            </ul>

            <div class="interactive-box">
                <h4>Interactive 8x4 RAM</h4>
                <div style="display: flex; flex-wrap: wrap; gap: 20px; justify-content: space-between;">
                    <!-- Controls -->
                    <div style="flex-basis: 300px;">
                        <strong>Controls:</strong><br>
                        Address (3-bit): <input type="text" id="ram-address" maxlength="3" value="000" pattern="[01]{3}"><br>
                        Data (4-bit): <input type="text" id="ram-data-in" maxlength="4" value="1100" pattern="[01]{4}"><br><br>
                        <button id="ram-read-btn">Read from Address</button>
                        <button id="ram-write-btn">Write to Address</button>
                    </div>
                    <!-- Data Bus -->
                    <div style="flex-basis: 300px;">
                        <strong>Data Bus (MDR):</strong>
                        <div id="ram-data-out" class="register-bits" style="background-color: var(--code-bg); padding: 5px; border-radius: 4px;">
                            <div class="bit">-</div><div class="bit">-</div><div class="bit">-</div><div class="bit">-</div>
                        </div>
                        <div id="ram-status" aria-live="polite" style="text-align: center; margin-top: 10px; height: 20px;">Ready</div>
                    </div>
                </div>
                 <!-- RAM Grid -->
                <div style="margin-top: 20px;">
                    <strong>RAM Memory Cells:</strong>
                    <div id="ram-grid-container" class="ram-grid" style="display: grid; grid-template-columns: auto 1fr; gap: 5px;">
                        <!-- Generated by JS -->
                    </div>
                </div>
            </div>

        </section>

        <hr>
        
        <section id="quiz" aria-labelledby="quiz-heading">
            <h2 id="quiz-heading">Check Your Understanding</h2>
            <p>Test your knowledge of this week's key concepts.</p>
            <div class="interactive-box">
                <form id="quiz-form">
                    <div class="quiz-question">
                        <p><strong>1. A circuit's output depends on both its current inputs and its previous state. This describes a:</strong></p>
                        <label><input type="radio" name="q1" value="a"> Combinational circuit</label><br>
                        <label><input type="radio" name="q1" value="b"> Sequential circuit</label><br>
                        <label><input type="radio" name="q1" value="c"> Arithmetic Logic Unit</label>
                        <div id="q1-feedback"></div>
                    </div>
                    <div class="quiz-question" style="margin-top: 20px;">
                        <p><strong>2. In a standard S'R' latch built from NAND gates, what is the hold state?</strong></p>
                        <label><input type="radio" name="q2" value="a"> S'=0, R'=0</label><br>
                        <label><input type="radio" name="q2" value="b"> S'=0, R'=1</label><br>
                        <label><input type="radio" name="q2" value="c"> S'=1, R'=1</label>
                        <div id="q2-feedback"></div>
                    </div>
                    <div class="quiz-question" style="margin-top: 20px;">
                        <p><strong>3. What is the primary purpose of a clock signal in a multi-bit register?</strong></p>
                        <label><input type="radio" name="q3" value="a"> To provide power to the flip-flops</label><br>
                        <label><input type="radio" name="q3" value="b"> To synchronize the state change of all bits</label><br>
                        <label><input type="radio" name="q3" value="c"> To clear the register to zero</label>
                        <div id="q3-feedback"></div>
                    </div>
                    <button type="submit" style="margin-top: 20px;">Submit Answers</button>
                </form>
                <div id="quiz-results" style="margin-top: 20px; font-weight: bold;"></div>
            </div>
        </section>
        
        <hr>

        <section id="references" aria-labelledby="references-heading">
            <h2 id="references-heading">References and Further Reading</h2>
            <ul style="list-style-type: none; padding-left: 0;">
                <li style="margin-bottom: 10px;">
                    Scott, J. C. (2009). <em>But How Do It Know? - The Basic Principles of Computers for Everyone</em>. A valuable, simplified introduction to the core concepts of computer operation.
                </li>
                <li>
                    Harris, D. M., & Harris, S. L. (2012). <em>Digital Design and Computer Architecture</em>. Morgan Kaufmann. A comprehensive textbook for a deeper dive into digital logic and computer architecture.
                </li>
            </ul>
        </section>

    </main>
    
    <footer>
         <p class="privacy-notice">Privacy Notice: This is a self-contained educational tool. No data is tracked or stored. All interactions are limited to your current session.</p>
    </footer>

    <script>
    document.addEventListener('DOMContentLoaded', function() {

        // --- SRT Data ---
        const srtContent = `1
00:00:00,720 --> 00:00:05,700
Aloha. So I just want to talk a little bit about sequential logic and memory.

2
00:00:06,260 --> 00:00:10,780
And that's this week. And I'll also talk a little bit about our assignment for this week.

3
00:00:11,580 --> 00:00:19,420
So in this module and learning platform, I'll be this video is going to be right here in the beginning.

4
00:00:21,160 --> 00:00:25,620
And then we'll get into what is sequential logic.

5
00:00:25,620 --> 00:00:32,260
OK, so memory is sequential, meaning there's a feedback loop.

6
00:00:32,380 --> 00:00:35,380
Something has to happen for something else to happen. Kind of a thing.

7
00:00:36,040 --> 00:00:40,960
So like in this case, a TV power button, there's no on off switch.

8
00:00:41,400 --> 00:00:44,520
It's just a button you push and it toggles it.

9
00:00:44,520 --> 00:00:49,160
So if the TV is off and you push the button, it turns on.

10
00:00:49,160 --> 00:00:52,980
If it's on and you push the button, it turns off.

11
00:00:52,980 --> 00:00:57,480
That's a sequential logic, meaning there's memory in that circuit.

12
00:00:57,480 --> 00:01:03,640
It knows what the state is, what the current state is, and it does the opposite to change the state.

13
00:01:04,360 --> 00:01:08,240
So we'll talk a little bit about that, how memory works.

14
00:01:08,240 --> 00:01:13,000
And in this case, we have a little simulator here that you can run.

15
00:01:13,000 --> 00:01:14,480
That's the interactive portion of this.

16
00:01:15,300 --> 00:01:16,880
We go into latches.

17
00:01:17,400 --> 00:01:23,800
OK, so this is another interactive learning experience where we can play with this.

18
00:01:23,800 --> 00:01:28,380
And we'll go through this in class as well, so that you can see how it works.

19
00:01:29,200 --> 00:01:31,440
Then we get into registers.

20
00:01:31,440 --> 00:01:35,900
And a register is a clocked system, meaning there's a clock.

21
00:01:36,120 --> 00:01:41,260
The clock provides a pulse and things happen on that pulse.

22
00:01:41,260 --> 00:01:46,620
So it's either on the leading edge or the trailing edge of the pulse where things get updated.

23
00:01:47,160 --> 00:01:48,960
So this is another simulation.

24
00:01:49,460 --> 00:01:54,780
Then we go to RAM, Random Access Memory, and there's a little simulation on this.

25
00:01:54,780 --> 00:01:58,840
Then we have a check your understanding, which is our little quiz.

26
00:01:58,840 --> 00:02:00,740
There's no points for this.

27
00:02:00,740 --> 00:02:05,040
It's just for you to see if you understood the content and the references.

28
00:02:05,960 --> 00:02:11,540
Now, the assignment for this week is to create an 8-bit register.

29
00:02:11,540 --> 00:02:15,720
OK, we need an 8-bit register for our CPU.

30
00:02:15,720 --> 00:02:17,460
We'll have three of them.

31
00:02:17,460 --> 00:02:22,820
So if we create one, we can just copy and paste the other two and then just change the labels on it.

32
00:02:23,520 --> 00:02:26,600
So to do this, we're going to use Logisim.

33
00:02:27,200 --> 00:02:32,840
And here are the requirements for that 8-bit register.

34
00:02:32,840 --> 00:02:39,080
Now, you can do this by using the built-in register in Logisim.

35
00:02:39,080 --> 00:02:40,560
There is a register in there.

36
00:02:40,940 --> 00:02:45,920
You can go in there and do that, but you have to know how to connect it.

37
00:02:45,920 --> 00:02:48,160
So you have to know how to read the documentation.

38
00:02:48,160 --> 00:02:50,960
So that's part of the assignment is to go in and read the documentation.

39
00:02:50,960 --> 00:02:53,460
See how to do it and then implement it.

40
00:02:53,460 --> 00:02:54,460
It's very easy.

41
00:02:55,200 --> 00:03:00,560
The alternative is to create it from a D flip flop.

42
00:03:00,560 --> 00:03:02,100
There's a D flip flop in there.

43
00:03:02,100 --> 00:03:07,460
So an 8 bit register is eight D flip flops side-by-side.

44
00:03:07,460 --> 00:03:10,340
And then you just manage all the wires.

45
00:03:10,340 --> 00:03:11,580
There's a lot of wires.

46
00:03:12,160 --> 00:03:15,900
Or you can go all the way down to the NAND gates.

47
00:03:15,900 --> 00:03:19,260
We saw in this S-R latch, we can do it with NAND gates.

48
00:03:19,260 --> 00:03:20,060
So we know that.

49
00:03:20,060 --> 00:03:23,880
So a D flip flop is just a couple of S-R latches.

50
00:03:23,880 --> 00:03:27,100
And then eight of those makes an 8 bit register.

51
00:03:27,100 --> 00:03:32,040
So you could build the whole thing from scratch with NAND gates if you want it.

52
00:03:32,040 --> 00:03:33,880
It is a lot of work.

53
00:03:33,880 --> 00:03:38,620
There's going to be a lot of wires, so you have to be very good with your wire management.

54
00:03:39,180 --> 00:03:41,200
But it's very doable.

55
00:03:41,200 --> 00:03:46,280
And it shows that you have a mastery of what's going on.

56
00:03:46,280 --> 00:03:52,480
Now, I recommend that you build this as a sub-circuit in our CPU.

57
00:03:52,480 --> 00:03:55,600
So we're going to build our entire CPU in one file.

58
00:03:55,900 --> 00:03:59,780
And we'll just have sub-circuits for each of the components.

59
00:03:59,780 --> 00:04:04,180
So that way, we have our main, which is our CPU.

60
00:04:04,180 --> 00:04:09,000
And then from our main, we'll have our sub-circuits, which will have our registers and our RAM.

61
00:04:09,000 --> 00:04:10,240
And then our ALU.

62
00:04:10,240 --> 00:04:13,240
And we'll have all the different components as sub-circuits.

63
00:04:13,240 --> 00:04:17,320
So that our main wiring diagram isn't that cluttered.

64
00:04:18,040 --> 00:04:22,860
OK, so that's the assignment. That's what we'll be doing.

65
00:04:22,860 --> 00:04:26,780
And we'll be doing this over the next couple of weeks.

66
00:04:26,780 --> 00:04:30,220
This week, we're doing the register and the RAM.

67
00:04:30,220 --> 00:04:33,020
Next week, we'll be doing something else and so forth.

68
00:04:33,020 --> 00:04:36,780
So we'll just be building this up as we go along.

69
00:04:36,780 --> 00:04:39,020
And we'll be doing this in class as well.

70
00:04:39,020 --> 00:04:41,260
So you'll have plenty of time to work on it.

71
00:04:41,260 --> 00:04:43,420
Plenty of time to ask questions.

72
00:04:43,420 --> 00:04:45,920
I have office hours for you to come and ask questions.

73
00:04:46,440 --> 00:04:49,140
So it should be a pretty fun project.

74
00:04:49,700 --> 00:04:51,940
So let's get into it.`;

        // --- Part 1: TV Toggle Button ---
        const toggleButton = document.getElementById('toggle-button');
        const tvLed = document.getElementById('tv-led');
        const tvStatus = document.getElementById('tv-status');
        let isTvOn = false;

        toggleButton.addEventListener('click', () => {
            isTvOn = !isTvOn;
            if (isTvOn) {
                tvLed.classList.add('on');
                tvStatus.textContent = 'On';
                toggleButton.setAttribute('aria-pressed', 'true');
            } else {
                tvLed.classList.remove('on');
                tvStatus.textContent = 'Off';
                toggleButton.setAttribute('aria-pressed', 'false');
            }
        });

        // --- Transcript Loader ---
        function parseSRT(srt) {
            const transcriptBox = document.getElementById('transcript-content-box');
            if (!transcriptBox) return;
            
            const entries = srt.trim().split(/\n\s*\n/);
            let html = '';

            for (const entry of entries) {
                const lines = entry.split('\n');
                if (lines.length >= 3) {
                    const time = lines[1].split(' --> ')[0];
                    const text = lines.slice(2).join(' ');
                    
                    // Format time as [mm:ss]
                    const timeParts = time.split(':');
                    const minutes = timeParts[1];
                    const seconds = timeParts[2].split(',')[0];
                    const formattedTime = `[${minutes}:${seconds}]`;

                    html += `<p><strong>${formattedTime}</strong> ${text}</p>`;
                }
            }
            transcriptBox.innerHTML = html;
        }
        
        parseSRT(srtContent);

        // --- Part 2: S'R' NAND Latch Simulator ---
        const sButton = document.getElementById('sr-s-button');
        const rButton = document.getElementById('sr-r-button');
        const qLed = document.getElementById('sr-q-led');
        const qnLed = document.getElementById('sr-qn-led');
        const srStatus = document.getElementById('sr-status');
        
        // SVG Elements
        const sWireIn = document.getElementById('s-wire-in');
        const sLabel = document.getElementById('s-label');
        const rWireIn = document.getElementById('r-wire-in');
        const rLabel = document.getElementById('r-label');
        const qWireOut = document.getElementById('q-wire-out');
        const qLabel = document.getElementById('q-label');
        const qNotWireOut = document.getElementById('q-not-wire-out');
        const qNotLabel = document.getElementById('q-not-label');
        const feedbackQ = document.getElementById('feedback-q');
        const feedbackQNot = document.getElementById('feedback-q-not');

        // S'R' Latch is active low, so initial state is 1,1 (Hold)
        let s_not = 1;
        let r_not = 1;
        let q = 0; // Start in a known reset state
        let qn = 1;

        function updateSrLatch() {
            // NAND Gate Logic Simulation
            // We loop a few times to allow the feedback to stabilize
            for (let i = 0; i < 5; i++) {
                qn = (s_not && q) ? 0 : 1; // Top gate
                q = (r_not && qn) ? 0 : 1; // Bottom gate
            }
            
            // Update LEDs
            qLed.classList.toggle('on', q === 1);
            qnLed.classList.toggle('on', qn === 1);

            // Update Status Text
            if (s_not === 0 && r_not === 0) {
                srStatus.textContent = 'State: Invalid!';
                srStatus.style.color = 'var(--danger-color)';
            } else if (s_not === 0 && r_not === 1) {
                srStatus.textContent = 'State: Set';
                srStatus.style.color = 'var(--primary-text)';
            } else if (s_not === 1 && r_not === 0) {
                srStatus.textContent = 'State: Reset';
                srStatus.style.color = 'var(--primary-text)';
            } else { // s_not=1, r_not=1
                srStatus.textContent = 'State: Hold';
                srStatus.style.color = 'var(--primary-text)';
            }
            
            // Update SVG Diagram
            updateSvgClass(sWireIn, s_not);
            updateSvgClass(sLabel, s_not);
            updateSvgClass(rWireIn, r_not);
            updateSvgClass(rLabel, r_not);
            updateSvgClass(qWireOut, q);
            updateSvgClass(qLabel, q);
            updateSvgClass(qNotWireOut, qn);
            updateSvgClass(qNotLabel, qn);
            updateSvgClass(feedbackQ, q);
            updateSvgClass(feedbackQNot, qn);
        }
        
        function updateSvgClass(element, state) {
            element.classList.remove('high', 'low');
            element.classList.add(state === 1 ? 'high' : 'low');
        }
        
        sButton.addEventListener('click', () => {
            s_not = 1 - s_not; // toggle 0/1
            sButton.textContent = `S' = ${s_not}`;
            sButton.classList.toggle('active', s_not === 0);
            sButton.setAttribute('aria-pressed', s_not === 0);
            updateSrLatch();
        });
        
        rButton.addEventListener('click', () => {
            r_not = 1 - r_not; // toggle 0/1
            rButton.textContent = `R' = ${r_not}`;
            rButton.classList.toggle('active', r_not === 0);
            rButton.setAttribute('aria-pressed', r_not === 0);
            updateSrLatch();
        });

        // Initialize
        updateSrLatch();

        // --- Part 3: Register Simulator ---
        const regInput = document.getElementById('reg-input');
        const loadButton = document.getElementById('reg-load-button');
        const clearButton = document.getElementById('reg-clear-button');
        const clockButton = document.getElementById('reg-clock-button');
        const regOutputBits = document.querySelectorAll('#register-q-output .bit');
        const regStatus = document.getElementById('reg-status');

        let registerValue = [0, 0, 0, 0];
        let loadEnabled = false;

        function updateRegisterDisplay() {
            registerValue.forEach((bit, index) => {
                regOutputBits[index].textContent = bit;
            });
        }

        loadButton.addEventListener('click', () => {
            loadEnabled = !loadEnabled;
            loadButton.classList.toggle('active', loadEnabled);
            loadButton.textContent = `Load Enable = ${loadEnabled ? 1 : 0}`;
            loadButton.setAttribute('aria-pressed', loadEnabled);
        });

        clearButton.addEventListener('click', () => {
            registerValue = [0, 0, 0, 0];
            updateRegisterDisplay();
            regStatus.textContent = "Register cleared.";
        });
        
        clockButton.addEventListener('click', () => {
            if (loadEnabled) {
                const inputValue = regInput.value.padStart(4, '0');
                if (/^[01]{4}$/.test(inputValue)) {
                    registerValue = inputValue.split('').map(Number);
                    updateRegisterDisplay();
                    regStatus.textContent = `Loaded value ${inputValue} on clock pulse.`;
                } else {
                    regStatus.textContent = "Invalid input. Use 4 binary digits.";
                }
            } else {
                regStatus.textContent = "Clock pulsed, but Load was disabled. Holding state.";
            }
        });
        
        updateRegisterDisplay();

        // --- Part 4: RAM Simulator ---
        const ramAddressInput = document.getElementById('ram-address');
        const ramDataInInput = document.getElementById('ram-data-in');
        const readBtn = document.getElementById('ram-read-btn');
        const writeBtn = document.getElementById('ram-write-btn');
        const dataOutBits = document.querySelectorAll('#ram-data-out .bit');
        const ramStatus = document.getElementById('ram-status');
        const ramGridContainer = document.getElementById('ram-grid-container');

        let ram = Array(8).fill(null).map(() => Array(4).fill(0));

        function createRamGrid() {
            ramGridContainer.innerHTML = ''; // Clear existing
            for (let i = 0; i < 8; i++) {
                const addressLabel = document.createElement('div');
                addressLabel.textContent = i.toString(2).padStart(3, '0');
                addressLabel.style.textAlign = 'right';
                addressLabel.style.fontFamily = '"Courier New", monospace';
                
                const row = document.createElement('div');
                row.classList.add('register-bits');
                row.dataset.address = i;

                for (let j = 0; j < 4; j++) {
                    const cell = document.createElement('div');
                    cell.classList.add('ram-cell');
                    cell.textContent = ram[i][j];
                    row.appendChild(cell);
                }
                ramGridContainer.appendChild(addressLabel);
                ramGridContainer.appendChild(row);
            }
        }
        
        function updateRamSelection(address) {
            document.querySelectorAll('.ram-grid .register-bits .ram-cell').forEach(cell => cell.classList.remove('selected'));
            if (address >= 0 && address < 8) {
                const selectedRow = document.querySelector(`.ram-grid .register-bits[data-address='${address}']`);
                if(selectedRow) {
                    selectedRow.querySelectorAll('.ram-cell').forEach(cell => cell.classList.add('selected'));
                }
            }
        }
        
        ramAddressInput.addEventListener('input', () => {
             const addr = parseInt(ramAddressInput.value, 2);
             if(!isNaN(addr)) updateRamSelection(addr);
        });

        writeBtn.addEventListener('click', () => {
            const addr = parseInt(ramAddressInput.value, 2);
            const data = ramDataInInput.value;
            if (isNaN(addr) || addr < 0 || addr > 7 || !/^[01]{4}$/.test(data)) {
                ramStatus.textContent = "Invalid address or data.";
                return;
            }
            ram[addr] = data.split('').map(Number);
            createRamGrid(); // Redraw grid with new data
            updateRamSelection(addr);
            ramStatus.textContent = `Wrote ${data} to address ${addr.toString(2).padStart(3, '0')}.`;
        });
        
        readBtn.addEventListener('click', () => {
            const addr = parseInt(ramAddressInput.value, 2);
            if (isNaN(addr) || addr < 0 || addr > 7) {
                ramStatus.textContent = "Invalid address.";
                return;
            }
            const data = ram[addr];
            data.forEach((bit, index) => {
                dataOutBits[index].textContent = bit;
            });
            updateRamSelection(addr);
            ramStatus.textContent = `Read ${data.join('')} from address ${addr.toString(2).padStart(3, '0')}.`;
        });

        // Initial RAM setup
        createRamGrid();

        // --- Quiz Section ---
        const quizForm = document.getElementById('quiz-form');
        const quizResults = document.getElementById('quiz-results');
        
        quizForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const answers = {
                q1: document.querySelector('input[name="q1"]:checked')?.value,
                q2: document.querySelector('input[name="q2"]:checked')?.value,
                q3: document.querySelector('input[name="q3"]:checked')?.value
            };
            
            const correctAnswers = { q1: 'b', q2: 'c', q3: 'b' };
            const feedback = {
                q1: "The correct answer is <strong>b) Sequential circuit</strong>. A sequential circuit's output depends on its past state (memory), while a combinational circuit's output depends only on its current inputs.",
                q2: "The correct answer is <strong>c) S'=1, R'=1</strong>. In a NAND-based S'R' latch, the inputs are active-low. Setting both to the inactive high state (1) causes the latch to hold its value.",
                q3: "The correct answer is <strong>b) To synchronize the state change of all bits</strong>. A clock pulse ensures all flip-flops in a register update at the exact same moment for coherent data storage."
            };

            let score = 0;
            const q1Feedback = document.getElementById('q1-feedback');
            const q2Feedback = document.getElementById('q2-feedback');
            const q3Feedback = document.getElementById('q3-feedback');

            // Clear previous feedback
            q1Feedback.innerHTML = '';
            q2Feedback.innerHTML = '';
            q3Feedback.innerHTML = '';

            // Question 1
            if (answers.q1 === correctAnswers.q1) {
                score++;
                q1Feedback.innerHTML = `<p style="color: var(--success-color); margin-top: 10px;"><strong>Correct!</strong></p>`;
            } else {
                q1Feedback.innerHTML = `<p style="color: var(--danger-color); margin-top: 10px;"><strong>Incorrect.</strong> ${feedback.q1}</p>`;
            }

            // Question 2
            if (answers.q2 === correctAnswers.q2) {
                score++;
                q2Feedback.innerHTML = `<p style="color: var(--success-color); margin-top: 10px;"><strong>Correct!</strong></p>`;
            } else {
                q2Feedback.innerHTML = `<p style="color: var(--danger-color); margin-top: 10px;"><strong>Incorrect.</strong> ${feedback.q2}</p>`;
            }

            // Question 3
            if (answers.q3 === correctAnswers.q3) {
                score++;
                q3Feedback.innerHTML = `<p style="color: var(--success-color); margin-top: 10px;"><strong>Correct!</strong></p>`;
            } else {
                q3Feedback.innerHTML = `<p style="color: var(--danger-color); margin-top: 10px;"><strong>Incorrect.</strong> ${feedback.q3}</p>`;
            }

            quizResults.textContent = `You scored ${score} out of 3.`;
             if(score === 3) {
                quizResults.style.color = 'var(--success-color)';
            } else {
                 quizResults.style.color = 'var(--danger-color)';
            }
        });
    });
    </script>
</body>
</html>

