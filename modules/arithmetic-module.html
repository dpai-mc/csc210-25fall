<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arithmetic Circuits - CSC210</title>
    <style>
/* 
 * CSC210 Module Shared Styles
 * Version: 1.0.0
 * 
 * This CSS file provides consistent styling across all modules
 * and ensures proper integration with the main learning platform.
 */

/* ===== CSS CUSTOM PROPERTIES (DESIGN SYSTEM) ===== */
:root {
    /* Primary Color Palette - Must match platform */
    --primary-color: #2563eb;
    --secondary-color: #3b82f6;
    --accent-color: #f59e0b;
    --success-color: #059669;
    --error-color: #dc2626;
    --warning-color: #d97706;
    --info-color: #0891b2;
    
    /* Background Colors */
    --bg-primary: #ffffff;
    --bg-secondary: #f8fafc;
    --bg-tertiary: #e2e8f0;
    --bg-inverse: #1e293b;
    
    /* Text Colors */
    --text-primary: #1e293b;
    --text-secondary: #475569;
    --text-muted: #64748b;
    --text-inverse: #f8fafc;
    
    /* Border and Shadow */
    --border-color: #e2e8f0;
    --border-color-hover: #cbd5e1;
    --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
    --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
    --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 10px 10px -5px rgb(0 0 0 / 0.04);
    
    /* Border Radius */
    --border-radius-sm: 0.25rem;
    --border-radius: 0.5rem;
    --border-radius-lg: 0.75rem;
    --border-radius-xl: 1rem;
    
    /* Spacing Scale */
    --space-1: 0.25rem;
    --space-2: 0.5rem;
    --space-3: 0.75rem;
    --space-4: 1rem;
    --space-5: 1.25rem;
    --space-6: 1.5rem;
    --space-8: 2rem;
    --space-10: 2.5rem;
    --space-12: 3rem;
    --space-16: 4rem;
    
    /* Typography */
    --font-family-base: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    --font-family-mono: 'Monaco', 'Cascadia Code', 'Consolas', monospace;
    
    --font-size-xs: 0.75rem;
    --font-size-sm: 0.875rem;
    --font-size-base: 1rem;
    --font-size-lg: 1.125rem;
    --font-size-xl: 1.25rem;
    --font-size-2xl: 1.5rem;
    --font-size-3xl: 1.875rem;
    --font-size-4xl: 2.25rem;
    
    --line-height-tight: 1.25;
    --line-height-normal: 1.5;
    --line-height-relaxed: 1.75;
    
    /* Transitions */
    --transition-fast: 0.15s ease;
    --transition-normal: 0.2s ease;
    --transition-slow: 0.3s ease;
}

/* ===== RESET AND BASE STYLES ===== */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

html {
    font-size: 16px;
    scroll-behavior: smooth;
}

body {
    font-family: var(--font-family-base);
    font-size: var(--font-size-base);
    line-height: var(--line-height-normal);
    color: var(--text-primary);
    background-color: var(--bg-primary);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

/* ===== TYPOGRAPHY ===== */
h1, h2, h3, h4, h5, h6 {
    font-weight: 600;
    line-height: var(--line-height-tight);
    margin-bottom: var(--space-4);
    color: var(--text-primary);
}

h1 { font-size: var(--font-size-4xl); }
h2 { font-size: var(--font-size-3xl); }
h3 { font-size: var(--font-size-2xl); }
h4 { font-size: var(--font-size-xl); }
h5 { font-size: var(--font-size-lg); }
h6 { font-size: var(--font-size-base); }

p {
    margin-bottom: var(--space-4);
    color: var(--text-secondary);
}

strong {
    font-weight: 600;
    color: var(--text-primary);
}

code {
    font-family: var(--font-family-mono);
    font-size: 0.875em;
    background-color: var(--bg-tertiary);
    padding: var(--space-1) var(--space-2);
    border-radius: var(--border-radius-sm);
    color: var(--text-primary);
}

/* ===== LAYOUT COMPONENTS ===== */
.module-container {
    max-width: 100%;
    margin: 0 auto;
    padding: var(--space-6);
    min-height: 100vh;
}

.section {
    margin-bottom: var(--space-8);
}

.section-header {
    margin-bottom: var(--space-6);
    padding-bottom: var(--space-4);
    border-bottom: 2px solid var(--border-color);
}

.grid {
    display: grid;
    gap: var(--space-6);
}

.grid-2 {
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
}

.flex {
    display: flex;
    gap: var(--space-4);
}

.flex-col {
    flex-direction: column;
}

.items-center {
    align-items: center;
}

.justify-between {
    justify-content: space-between;
}

.justify-center {
    justify-content: center;
}

/* ===== CARD COMPONENTS ===== */
.card {
    background-color: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius-lg);
    box-shadow: var(--shadow-md);
    padding: var(--space-6);
    margin-bottom: var(--space-6);
    transition: box-shadow var(--transition-normal);
}

.card:hover {
    box-shadow: var(--shadow-lg);
}

.card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space-4);
    padding-bottom: var(--space-4);
    border-bottom: 1px solid var(--border-color);
}

.card-title {
    font-size: var(--font-size-xl);
    font-weight: 600;
    color: var(--text-primary);
    margin: 0;
}

/* ===== INTERACTIVE ELEMENTS ===== */
.btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-2);
    padding: var(--space-3) var(--space-6);
    font-size: var(--font-size-sm);
    font-weight: 500;
    text-decoration: none;
    border: none;
    border-radius: var(--border-radius);
    cursor: pointer;
    transition: all var(--transition-normal);
    min-height: 44px;
    min-width: 44px;
}

.btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none !important;
}

.btn-primary {
    background-color: var(--primary-color);
    color: white;
}

.btn-primary:hover:not(:disabled) {
    background-color: #1d4ed8;
    transform: translateY(-1px);
    box-shadow: var(--shadow-lg);
}

.btn-secondary {
    background-color: var(--bg-tertiary);
    color: var(--text-primary);
}

.btn-secondary:hover:not(:disabled) {
    background-color: #cbd5e1;
    transform: translateY(-1px);
}

.btn-success {
    background-color: var(--success-color);
    color: white;
}

.btn-success:hover:not(:disabled) {
    background-color: #047857;
    transform: translateY(-1px);
}

.btn-small {
    padding: var(--space-2) var(--space-4);
    font-size: var(--font-size-xs);
    min-height: 32px;
    min-width: 32px;
}

/* ===== FORM CONTROLS ===== */
.checkbox-group {
    display: flex;
    align-items: center;
    gap: var(--space-2);
    margin-bottom: var(--space-3);
}

.checkbox {
    width: 18px;
    height: 18px;
    accent-color: var(--primary-color);
}

.checkbox-label {
    font-size: var(--font-size-sm);
    color: var(--text-secondary);
    cursor: pointer;
    user-select: none;
}

/* ===== SIMULATOR COMPONENTS ===== */
.simulator-container {
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius-lg);
    padding: var(--space-6);
    margin: var(--space-6) 0;
}

.simulator-controls {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: var(--space-6);
    margin-bottom: var(--space-6);
}

.control-group {
    background-color: var(--bg-primary);
    padding: var(--space-4);
    border-radius: var(--border-radius);
    border: 1px solid var(--border-color);
}

.control-group h4 {
    font-size: var(--font-size-lg);
    margin-bottom: var(--space-3);
    color: var(--text-primary);
}

.output-display {
    background-color: var(--bg-primary);
    border: 2px solid var(--success-color);
    border-radius: var(--border-radius);
    padding: var(--space-4);
    margin: var(--space-4) 0;
    text-align: center;
}

.output-value {
    font-family: var(--font-family-mono);
    font-size: var(--font-size-2xl);
    font-weight: 600;
    color: var(--success-color);
}

/* ===== TRUTH TABLE STYLES ===== */
.truth-table {
    width: 100%;
    border-collapse: collapse;
    margin: var(--space-6) 0;
    font-size: var(--font-size-sm);
    background-color: var(--bg-primary);
    border-radius: var(--border-radius);
    overflow: hidden;
    box-shadow: var(--shadow-md);
}

.truth-table th,
.truth-table td {
    padding: var(--space-3);
    text-align: center;
    border: 1px solid var(--border-color);
}

.truth-table th {
    background-color: var(--primary-color);
    color: white;
    font-weight: 600;
    font-size: var(--font-size-sm);
}

.truth-table tbody tr:nth-child(even) {
    background-color: var(--bg-secondary);
}

.truth-table tbody tr:hover {
    background-color: var(--bg-tertiary);
}

.truth-table .active-row {
    background-color: #fef3c7 !important;
    font-weight: 600;
    box-shadow: inset 0 0 0 2px var(--warning-color);
}

/* ===== PROGRESS INDICATORS ===== */
.progress-container {
    margin: var(--space-6) 0;
}

.progress-bar {
    width: 100%;
    height: 8px;
    background-color: var(--bg-tertiary);
    border-radius: 9999px;
    overflow: hidden;
    margin: var(--space-2) 0;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--primary-color) 0%, var(--secondary-color) 100%);
    border-radius: 9999px;
    transition: width var(--transition-slow);
    position: relative;
    width: 0%;
}

.progress-text {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: var(--font-size-sm);
    color: var(--text-secondary);
}

/* ===== QUIZ STYLES ===== */
.quiz-container {
    background-color: var(--bg-secondary);
    border-radius: var(--border-radius-lg);
    padding: var(--space-6);
    margin: var(--space-6) 0;
}

.quiz-question {
    margin-bottom: var(--space-8);
    background-color: var(--bg-primary);
    padding: var(--space-6);
    border-radius: var(--border-radius);
    border: 1px solid var(--border-color);
}

.quiz-question h4 {
    margin-bottom: var(--space-4);
}

.quiz-options {
    list-style: none;
    margin-bottom: var(--space-4);
}

.quiz-option {
    margin-bottom: var(--space-3);
}

.quiz-option label {
    display: flex;
    align-items: flex-start;
    gap: var(--space-3);
    padding: var(--space-4);
    background-color: var(--bg-secondary);
    border: 2px solid var(--border-color);
    border-radius: var(--border-radius);
    cursor: pointer;
    transition: all var(--transition-normal);
    min-height: 44px;
}

.quiz-option label:hover {
    border-color: var(--primary-color);
    background-color: #eff6ff;
}

.quiz-option input[type="radio"] {
    margin-top: 2px;
}

.quiz-feedback {
    margin-top: var(--space-4);
    padding: var(--space-4);
    border-radius: var(--border-radius);
    display: none;
}

.quiz-feedback.correct {
    background-color: #dcfce7;
    color: var(--success-color);
    border: 1px solid var(--success-color);
    display: block;
}

.quiz-feedback.incorrect {
    background-color: #fee2e2;
    color: var(--error-color);
    border: 1px solid var(--error-color);
    display: block;
}

/* ===== ACCESSIBILITY ENHANCEMENTS ===== */
.sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
}

.skip-link {
    position: absolute;
    top: -40px;
    left: var(--space-2);
    background-color: var(--primary-color);
    color: white;
    padding: var(--space-2) var(--space-4);
    text-decoration: none;
    border-radius: var(--border-radius);
    z-index: 1000;
    font-weight: 500;
}

.skip-link:focus {
    top: var(--space-2);
}

button:focus,
input:focus,
select:focus,
textarea:focus,
.btn:focus {
    outline: 2px solid var(--accent-color);
    outline-offset: 2px;
}

/* ===== RESPONSIVE DESIGN ===== */
@media (min-width: 768px) {
    .module-container {
        padding: var(--space-10);
    }
    
    .simulator-controls {
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    }
    
    h1 { font-size: 3rem; }
    h2 { font-size: 2.5rem; }
}

@media (min-width: 1024px) {
    .module-container {
        max-width: 1200px;
        padding: var(--space-12);
    }
    
    .simulator-controls {
        grid-template-columns: repeat(3, 1fr);
    }
}

/* ===== UTILITY CLASSES ===== */
.text-center { text-align: center; }
.font-bold { font-weight: 600; }
.hidden { display: none; }

/* Circuit diagram interactive states */
.circuit-diagram .input-pin-high {
    fill: #27ae60 !important;
    stroke: #1e8449 !important;
}

.circuit-diagram .input-pin-low {
    fill: #95a5a6 !important;
    stroke: #7f8c8d !important;
}

.circuit-diagram .output-pin-high {
    fill: #e74c3c !important;
    stroke: #c0392b !important;
    filter: drop-shadow(0 0 3px #e74c3c);
}

.circuit-diagram .output-pin-low {
    fill: #95a5a6 !important;
    stroke: #7f8c8d !important;
}

.circuit-diagram .signal-high {
    stroke: #27ae60 !important;
    stroke-width: 3 !important;
    filter: drop-shadow(0 0 2px #27ae60);
}

.circuit-diagram .signal-low {
    stroke: #95a5a6 !important;
    stroke-width: 2 !important;
}

.circuit-diagram .gate-active {
    fill: #e8f5e8 !important;
    stroke: #27ae60 !important;
    stroke-width: 2 !important;
}

.circuit-diagram .carry-chain-active {
    stroke: #f39c12 !important;
    stroke-width: 4 !important;
    filter: drop-shadow(0 0 2px #f39c12);
}

/* Animation for signal flow */
@keyframes signal-flow {
    0% { stroke-dashoffset: 0; }
    100% { stroke-dashoffset: 20; }
}

.circuit-diagram .signal-animated {
    stroke-dasharray: 5, 5;
    animation: signal-flow 0.5s linear infinite;
}
    </style>
</head>
<body>
    <!-- Skip link for accessibility -->
    <a href="#main-content" class="skip-link">Skip to main content</a>
    
    <!-- Module content structure -->
    <main class="module-container" id="main-content">
        <header class="section-header">
            <h1>Arithmetic Circuits</h1>
            <div class="progress-container">
                <div class="progress-text">
                    <span>Progress</span>
                    <span id="progress-text">0%</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="module-progress"></div>
                </div>
            </div>
        </header>
        
        <!-- Section 1: Half-Adder -->
        <section class="section" id="half-adder-section">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Half-Adder Circuit</h2>
                </div>
                
                <p>A half-adder is a fundamental digital circuit that performs addition of two single binary digits. It produces two outputs: a Sum and a Carry. The Sum output represents the result of addition (A ⊕ B), while the Carry output represents any overflow (A • B).</p>
                
                <div class="simulator-container">
                    <h3 class="text-center">Interactive Half-Adder Simulator</h3>
                    
                    <div class="simulator-controls">
                        <div class="control-group">
                            <h4>Inputs</h4>
                            <div class="checkbox-group">
                                <input type="checkbox" id="ha-input-a" class="checkbox" aria-label="Half-adder input A">
                                <label for="ha-input-a" class="checkbox-label">Input A</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="ha-input-b" class="checkbox" aria-label="Half-adder input B">
                                <label for="ha-input-b" class="checkbox-label">Input B</label>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <h4>Circuit Diagram</h4>
                            <!-- Logisim-style diagram will go here -->
                            <div id="ha-circuit-container" style="width: 100%; height: 200px; border: 1px solid #e2e8f0; background: white;">
                                <!-- Half-Adder Circuit Diagram (matches Logisim standards) -->
<svg id="ha-logisim-diagram" width="400" height="200" viewBox="0 0 400 200" class="circuit-diagram" style="border: 1px solid #ccc; background: white;">
    <!-- Grid background (optional, similar to Logisim) -->
    <defs>
        <pattern id="grid" width="10" height="10" patternUnits="userSpaceOnUse">
            <path d="M 10 0 L 0 0 0 10" fill="none" stroke="#f0f0f0" stroke-width="0.5"/>
        </pattern>
    </defs>
    <rect width="100%" height="100%" fill="url(#grid)" />
    
    <!-- Input pins (Logisim style - small squares) -->
    <!-- Input A -->
    <rect x="20" y="55" width="8" height="8" fill="#4a90e2" stroke="#2c5aa0" stroke-width="1" id="ha-input-pin-a"/>
    <text x="15" y="52" font-family="Arial, sans-serif" font-size="11" fill="#000">A</text>
    <line x1="28" y1="59" x2="80" y2="59" stroke="#000" stroke-width="2"/>
    
    <!-- Input B -->
    <rect x="20" y="115" width="8" height="8" fill="#4a90e2" stroke="#2c5aa0" stroke-width="1" id="ha-input-pin-b"/>
    <text x="15" y="112" font-family="Arial, sans-serif" font-size="11" fill="#000">B</text>
    <line x1="28" y1="119" x2="80" y2="119" stroke="#000" stroke-width="2"/>
    
    <!-- Connection lines from inputs to gates -->
    <line x1="80" y1="59" x2="80" y2="79" stroke="#000" stroke-width="2"/>
    <line x1="80" y1="79" x2="120" y2="79" stroke="#000" stroke-width="2"/>
    <line x1="80" y1="119" x2="80" y2="99" stroke="#000" stroke-width="2"/>
    <line x1="80" y1="99" x2="120" y2="99" stroke="#000" stroke-width="2"/>
    
    <!-- Branch to AND gate -->
    <circle cx="80" cy="79" r="2" fill="#000"/>
    <line x1="80" y1="79" x2="120" y2="139" stroke="#000" stroke-width="2"/>
    <circle cx="80" cy="99" r="2" fill="#000"/>
    <line x1="80" y1="99" x2="120" y2="159" stroke="#000" stroke-width="2"/>
    
    <!-- XOR Gate (Logisim style with curved input) -->
    <g id="ha-xor-gate">
        <!-- XOR gate body -->
        <path d="M 120 65 Q 140 65 160 89 Q 140 113 120 113 Q 135 89 120 65" 
              fill="white" stroke="#000" stroke-width="2"/>
        <!-- Extra curve for XOR -->
        <path d="M 115 65 Q 130 89 115 113" fill="none" stroke="#000" stroke-width="2"/>
        <!-- Input lines -->
        <line x1="120" y1="79" x2="125" y2="79" stroke="#000" stroke-width="2"/>
        <line x1="120" y1="99" x2="125" y2="99" stroke="#000" stroke-width="2"/>
        <!-- Output line -->
        <line x1="160" y1="89" x2="180" y2="89" stroke="#000" stroke-width="2"/>
    </g>
    
    <!-- AND Gate (Logisim style D-shape) -->
    <g id="ha-and-gate">
        <!-- AND gate body -->
        <path d="M 120 125 L 145 125 Q 160 125 160 149 Q 160 173 145 173 L 120 173 Z" 
              fill="white" stroke="#000" stroke-width="2"/>
        <!-- Input lines -->
        <line x1="120" y1="139" x2="120" y2="139" stroke="#000" stroke-width="2"/>
        <line x1="120" y1="159" x2="120" y2="159" stroke="#000" stroke-width="2"/>
        <!-- Output line -->
        <line x1="160" y1="149" x2="180" y2="149" stroke="#000" stroke-width="2"/>
    </g>
    
    <!-- Output pins (Logisim style - small squares) -->
    <!-- Sum output -->
    <line x1="180" y1="89" x2="320" y2="89" stroke="#000" stroke-width="2"/>
    <rect x="320" y="85" width="8" height="8" fill="#e74c3c" stroke="#c0392b" stroke-width="1" id="ha-sum-pin"/>
    <text x="335" y="92" font-family="Arial, sans-serif" font-size="11" fill="#000">Sum</text>
    
    <!-- Carry output -->
    <line x1="180" y1="149" x2="320" y2="149" stroke="#000" stroke-width="2"/>
    <rect x="320" y="145" width="8" height="8" fill="#e74c3c" stroke="#c0392b" stroke-width="1" id="ha-carry-pin"/>
    <text x="335" y="152" font-family="Arial, sans-serif" font-size="11" fill="#000">Carry</text>
    
    <!-- Gate labels -->
    <text x="140" y="92" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#666">XOR</text>
    <text x="140" y="152" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#666">AND</text>
</svg>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <h4>Outputs</h4>
                            <div class="output-display">
                                <div>Sum: <span class="output-value" id="ha-sum">0</span></div>
                                <div>Carry: <span class="output-value" id="ha-carry">0</span></div>
                            </div>
                            <p><strong>Sum = A ⊕ B</strong></p>
                            <p><strong>Carry = A • B</strong></p>
                        </div>
                    </div>
                    
                    <div class="truth-table-container">
                        <h4>Truth Table</h4>
                        <table class="truth-table" id="ha-truth-table" aria-label="Half-adder truth table">
                            <thead>
                                <tr><th>A</th><th>B</th><th>Sum</th><th>Carry</th></tr>
                            </thead>
                            <tbody>
                                <tr data-inputs="0,0"><td>0</td><td>0</td><td>0</td><td>0</td></tr>
                                <tr data-inputs="0,1"><td>0</td><td>1</td><td>1</td><td>0</td></tr>
                                <tr data-inputs="1,0"><td>1</td><td>0</td><td>1</td><td>0</td></tr>
                                <tr data-inputs="1,1"><td>1</td><td>1</td><td>0</td><td>1</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </section>
        
        <!-- Section 2: Full-Adder -->
        <section class="section" id="full-adder-section">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Full-Adder Circuit</h2>
                </div>
                
                <p>A full-adder extends the half-adder by accepting three inputs: two operands (A, B) and a carry-in (Cin) from a previous stage. This allows for cascading multiple adders to perform multi-bit addition. The outputs are Sum = A ⊕ B ⊕ Cin and Carry-out = AB + Cin(A ⊕ B).</p>
                
                <div class="simulator-container">
                    <h3 class="text-center">Interactive Full-Adder Simulator</h3>
                    
                    <div class="simulator-controls">
                        <div class="control-group">
                            <h4>Inputs</h4>
                            <div class="checkbox-group">
                                <input type="checkbox" id="fa-input-a" class="checkbox" aria-label="Full-adder input A">
                                <label for="fa-input-a" class="checkbox-label">Input A</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="fa-input-b" class="checkbox" aria-label="Full-adder input B">
                                <label for="fa-input-b" class="checkbox-label">Input B</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="fa-input-cin" class="checkbox" aria-label="Full-adder carry in">
                                <label for="fa-input-cin" class="checkbox-label">Carry In</label>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <h4>Circuit Diagram</h4>
                            <!-- Logisim-style diagram will go here -->
                            <div id="fa-circuit-container" style="width: 100%; height: 250px; border: 1px solid #e2e8f0; background: white;">
                               <!-- Full-Adder Circuit Diagram (using two half-adders + OR gate) -->
<svg id="fa-logisim-diagram" width="600" height="300" viewBox="0 0 600 300" class="circuit-diagram" style="border: 1px solid #ccc; background: white;">
    <!-- Grid background -->
    <rect width="100%" height="100%" fill="url(#grid)" />
    
    <!-- Input pins -->
    <!-- Input A -->
    <rect x="20" y="75" width="8" height="8" fill="#4a90e2" stroke="#2c5aa0" stroke-width="1" id="fa-input-pin-a"/>
    <text x="15" y="72" font-family="Arial, sans-serif" font-size="11" fill="#000">A</text>
    <line x1="28" y1="79" x2="60" y2="79" stroke="#000" stroke-width="2"/>
    
    <!-- Input B -->
    <rect x="20" y="135" width="8" height="8" fill="#4a90e2" stroke="#2c5aa0" stroke-width="1" id="fa-input-pin-b"/>
    <text x="15" y="132" font-family="Arial, sans-serif" font-size="11" fill="#000">B</text>
    <line x1="28" y1="139" x2="60" y2="139" stroke="#000" stroke-width="2"/>
    
    <!-- Input Cin -->
    <rect x="20" y="195" width="8" height="8" fill="#4a90e2" stroke="#2c5aa0" stroke-width="1" id="fa-input-pin-cin"/>
    <text x="8" y="192" font-family="Arial, sans-serif" font-size="11" fill="#000">Cin</text>
    <line x1="28" y1="199" x2="280" y2="199" stroke="#000" stroke-width="2"/>
    
    <!-- First Half-Adder Block -->
    <g id="fa-half-adder-1">
        <rect x="60" y="95" width="80" height="50" fill="#f0f8ff" stroke="#4a90e2" stroke-width="2" rx="5"/>
        <text x="100" y="115" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" fill="#000">Half</text>
        <text x="100" y="128" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" fill="#000">Adder</text>
        
        <!-- Connections to first half-adder -->
        <line x1="60" y1="79" x2="60" y2="105" stroke="#000" stroke-width="2"/>
        <line x1="60" y1="139" x2="60" y2="135" stroke="#000" stroke-width="2"/>
        
        <!-- First half-adder outputs -->
        <line x1="140" y1="110" x2="180" y2="110" stroke="#000" stroke-width="2"/>
        <text x="150" y="107" font-family="Arial, sans-serif" font-size="8" fill="#666">S1</text>
        <line x1="140" y1="130" x2="170" y2="130" stroke="#000" stroke-width="2"/>
        <text x="150" y="127" font-family="Arial, sans-serif" font-size="8" fill="#666">C1</text>
    </g>
    
    <!-- Second Half-Adder Block -->
    <g id="fa-half-adder-2">
        <rect x="280" y="155" width="80" height="50" fill="#f0f8ff" stroke="#4a90e2" stroke-width="2" rx="5"/>
        <text x="320" y="175" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" fill="#000">Half</text>
        <text x="320" y="188" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" fill="#000">Adder</text>
        
        <!-- Connections to second half-adder -->
        <line x1="180" y1="110" x2="280" y2="110" stroke="#000" stroke-width="2"/>
        <line x1="280" y1="110" x2="280" y2="165" stroke="#000" stroke-width="2"/>
        <line x1="280" y1="199" x2="280" y2="195" stroke="#000" stroke-width="2"/>
        
        <!-- Second half-adder outputs -->
        <line x1="360" y1="170" x2="420" y2="170" stroke="#000" stroke-width="2"/>
        <text x="380" y="167" font-family="Arial, sans-serif" font-size="8" fill="#666">Sum</text>
        <line x1="360" y1="190" x2="390" y2="190" stroke="#000" stroke-width="2"/>
        <text x="370" y="187" font-family="Arial, sans-serif" font-size="8" fill="#666">C2</text>
    </g>
    
    <!-- OR Gate for final carry -->
    <g id="fa-or-gate">
        <!-- OR gate body (Logisim style curved) -->
        <path d="M 390 155 Q 410 155 420 170 Q 410 185 390 185 Q 405 170 390 155" 
              fill="white" stroke="#000" stroke-width="2"/>
        <!-- Input connections -->
        <line x1="170" y1="130" x2="170" y2="160" stroke="#000" stroke-width="2"/>
        <line x1="170" y1="160" x2="390" y2="160" stroke="#000" stroke-width="2"/>
        <line x1="390" y1="190" x2="390" y2="180" stroke="#000" stroke-width="2"/>
        <!-- Output -->
        <line x1="420" y1="170" x2="450" y2="170" stroke="#000" stroke-width="2"/>
    </g>
    
    <!-- Output pins -->
    <!-- Sum output -->
    <line x1="420" y1="170" x2="500" y2="170" stroke="#000" stroke-width="2"/>
    <rect x="500" y="166" width="8" height="8" fill="#e74c3c" stroke="#c0392b" stroke-width="1" id="fa-sum-pin"/>
    <text x="515" y="173" font-family="Arial, sans-serif" font-size="11" fill="#000">Sum</text>
    
    <!-- Carry output -->
    <line x1="450" y1="170" x2="500" y2="130" stroke="#000" stroke-width="2"/>
    <rect x="500" y="126" width="8" height="8" fill="#e74c3c" stroke="#c0392b" stroke-width="1" id="fa-cout-pin"/>
    <text x="515" y="133" font-family="Arial, sans-serif" font-size="11" fill="#000">Cout</text>
    
    <!-- Gate label -->
    <text x="405" y="173" text-anchor="middle" font-family="Arial, sans-serif" font-size="9" fill="#666">OR</text>
</svg>
                                
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <h4>Outputs</h4>
                            <div class="output-display">
                                <div>Sum: <span class="output-value" id="fa-sum">0</span></div>
                                <div>Carry Out: <span class="output-value" id="fa-carry">0</span></div>
                            </div>
                            <p><strong>Sum = A ⊕ B ⊕ Cin</strong></p>
                            <p><strong>Cout = AB + Cin(A ⊕ B)</strong></p>
                        </div>
                    </div>
                    
                    <div class="truth-table-container">
                        <h4>Truth Table</h4>
                        <table class="truth-table" id="fa-truth-table" aria-label="Full-adder truth table">
                            <thead>
                                <tr><th>A</th><th>B</th><th>Cin</th><th>Sum</th><th>Cout</th></tr>
                            </thead>
                            <tbody>
                                <tr data-inputs="0,0,0"><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
                                <tr data-inputs="0,0,1"><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td></tr>
                                <tr data-inputs="0,1,0"><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr>
                                <tr data-inputs="0,1,1"><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td></tr>
                                <tr data-inputs="1,0,0"><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td></tr>
                                <tr data-inputs="1,0,1"><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td></tr>
                                <tr data-inputs="1,1,0"><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr>
                                <tr data-inputs="1,1,1"><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </section>
        
        <!-- Section 3: 4-Bit Ripple-Carry Adder -->
        <section class="section" id="ripple-carry-section">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">4-Bit Ripple-Carry Adder</h2>
                </div>
                
                <p>A 4-bit ripple-carry adder chains four full-adders together to perform addition of two 4-bit binary numbers. The carry output from each stage "ripples" to the carry input of the next stage, creating a cascaded addition process. While simple to understand, the ripple-carry design has timing limitations due to carry propagation delays.</p>
                
                <div class="simulator-container">
                    <h3 class="text-center">Interactive 4-Bit Ripple-Carry Adder Simulator</h3>
                    
                    <div class="simulator-controls">
                        <div class="control-group">
                            <h4>4-bit Input A</h4>
                            <div class="checkbox-group">
                                <input type="checkbox" id="rc-a3" class="checkbox">
                                <label for="rc-a3" class="checkbox-label">A₃ (MSB)</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="rc-a2" class="checkbox">
                                <label for="rc-a2" class="checkbox-label">A₂</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="rc-a1" class="checkbox">
                                <label for="rc-a1" class="checkbox-label">A₁</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="rc-a0" class="checkbox">
                                <label for="rc-a0" class="checkbox-label">A₀ (LSB)</label>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <h4>4-bit Input B</h4>
                            <div class="checkbox-group">
                                <input type="checkbox" id="rc-b3" class="checkbox">
                                <label for="rc-b3" class="checkbox-label">B₃ (MSB)</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="rc-b2" class="checkbox">
                                <label for="rc-b2" class="checkbox-label">B₂</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="rc-b1" class="checkbox">
                                <label for="rc-b1" class="checkbox-label">B₁</label>
                            </div>
                            <div class="checkbox-group">
                                <input type="checkbox" id="rc-b0" class="checkbox">
                                <label for="rc-b0" class="checkbox-label">B₀ (LSB)</label>
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <h4>Results & Control</h4>
                            <div class="checkbox-group">
                                <input type="checkbox" id="rc-carry-in" class="checkbox">
                                <label for="rc-carry-in" class="checkbox-label">Carry In</label>
                            </div>
                            <div class="output-display">
                                <div>Binary: <span class="output-value" id="rc-sum-binary">0000</span></div>
                                <div>Decimal: <span class="output-value" id="rc-sum-decimal">0</span></div>
                                <div>Carry Out: <span class="output-value" id="rc-carry-out">0</span></div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <h4>Circuit Diagram</h4>
                        <!-- Logisim-style 4-bit adder diagram -->
                        <div id="rc-circuit-container" style="width: 100%; height: 300px; border: 1px solid #e2e8f0; background: white;">
                            <!-- 4-Bit Ripple-Carry Adder Diagram -->
<svg id="rc-logisim-diagram" width="700" height="350" viewBox="0 0 700 350" class="circuit-diagram" style="border: 1px solid #ccc; background: white;">
    <!-- Grid background -->
    <rect width="100%" height="100%" fill="url(#grid)" />
    
    <!-- Input labels and pins -->
    <!-- A inputs (top) -->
    <text x="80" y="35" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#000">A₃</text>
    <rect x="76" y="40" width="8" height="8" fill="#4a90e2" stroke="#2c5aa0" stroke-width="1" id="rc-a3-pin"/>
    <line x1="80" y1="48" x2="80" y2="80" stroke="#000" stroke-width="2"/>
    
    <text x="180" y="35" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#000">A₂</text>
    <rect x="176" y="40" width="8" height="8" fill="#4a90e2" stroke="#2c5aa0" stroke-width="1" id="rc-a2-pin"/>
    <line x1="180" y1="48" x2="180" y2="80" stroke="#000" stroke-width="2"/>
    
    <text x="280" y="35" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#000">A₁</text>
    <rect x="276" y="40" width="8" height="8" fill="#4a90e2" stroke="#2c5aa0" stroke-width="1" id="rc-a1-pin"/>
    <line x1="280" y1="48" x2="280" y2="80" stroke="#000" stroke-width="2"/>
    
    <text x="380" y="35" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#000">A₀</text>
    <rect x="376" y="40" width="8" height="8" fill="#4a90e2" stroke="#2c5aa0" stroke-width="1" id="rc-a0-pin"/>
    <line x1="380" y1="48" x2="380" y2="80" stroke="#000" stroke-width="2"/>
    
    <!-- B inputs (top right of each FA) -->
    <text x="120" y="35" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#000">B₃</text>
    <rect x="116" y="40" width="8" height="8" fill="#4a90e2" stroke="#2c5aa0" stroke-width="1" id="rc-b3-pin"/>
    <line x1="120" y1="48" x2="120" y2="80" stroke="#000" stroke-width="2"/>
    
    <text x="220" y="35" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#000">B₂</text>
    <rect x="216" y="40" width="8" height="8" fill="#4a90e2" stroke="#2c5aa0" stroke-width="1" id="rc-b2-pin"/>
    <line x1="220" y1="48" x2="220" y2="80" stroke="#000" stroke-width="2"/>
    
    <text x="320" y="35" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#000">B₁</text>
    <rect x="316" y="40" width="8" height="8" fill="#4a90e2" stroke="#2c5aa0" stroke-width="1" id="rc-b1-pin"/>
    <line x1="320" y1="48" x2="320" y2="80" stroke="#000" stroke-width="2"/>
    
    <text x="420" y="35" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#000">B₀</text>
    <rect x="416" y="40" width="8" height="8" fill="#4a90e2" stroke="#2c5aa0" stroke-width="1" id="rc-b0-pin"/>
    <line x1="420" y1="48" x2="420" y2="80" stroke="#000" stroke-width="2"/>
    
    <!-- Full Adder blocks (Logisim style) -->
    <!-- FA3 (MSB) -->
    <g id="rc-fa3">
        <rect x="50" y="80" width="100" height="70" fill="#fff8dc" stroke="#4a90e2" stroke-width="2" rx="5"/>
        <text x="100" y="105" text-anchor="middle" font-family="Arial, sans-serif" font-size="12" fill="#000">Full Adder</text>
        <text x="100" y="120" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" fill="#666">FA₃</text>
        <!-- Input connections -->
        <line x1="80" y1="80" x2="80" y2="90" stroke="#000" stroke-width="2"/>
        <line x1="120" y1="80" x2="120" y2="90" stroke="#000" stroke-width="2"/>
        <!-- Sum output -->
        <line x1="100" y1="150" x2="100" y2="180" stroke="#000" stroke-width="2"/>
        <rect x="96" y="180" width="8" height="8" fill="#e74c3c" stroke="#c0392b" stroke-width="1" id="rc-s3-pin"/>
        <text x="100" y="200" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#000">S₃</text>
        <!-- Carry out -->
        <line x1="50" y1="115" x2="30" y2="115" stroke="#f39c12" stroke-width="3"/>
    </g>
    
    <!-- FA2 -->
    <g id="rc-fa2">
        <rect x="150" y="80" width="100" height="70" fill="#fff8dc" stroke="#4a90e2" stroke-width="2" rx="5"/>
        <text x="200" y="105" text-anchor="middle" font-family="Arial, sans-serif" font-size="12" fill="#000">Full Adder</text>
        <text x="200" y="120" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" fill="#666">FA₂</text>
        <!-- Input connections -->
        <line x1="180" y1="80" x2="180" y2="90" stroke="#000" stroke-width="2"/>
        <line x1="220" y1="80" x2="220" y2="90" stroke="#000" stroke-width="2"/>
        <!-- Sum output -->
        <line x1="200" y1="150" x2="200" y2="180" stroke="#000" stroke-width="2"/>
        <rect x="196" y="180" width="8" height="8" fill="#e74c3c" stroke="#c0392b" stroke-width="1" id="rc-s2-pin"/>
        <text x="200" y="200" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#000">S₂</text>
        <!-- Carry chain -->
        <line x1="150" y1="115" x2="30" y2="115" stroke="#f39c12" stroke-width="3"/>
        <line x1="30" y1="115" x2="50" y2="115" stroke="#f39c12" stroke-width="3"/>
    </g>
    
    <!-- FA1 -->
    <g id="rc-fa1">
        <rect x="250" y="80" width="100" height="70" fill="#fff8dc" stroke="#4a90e2" stroke-width="2" rx="5"/>
        <text x="300" y="105" text-anchor="middle" font-family="Arial, sans-serif" font-size="12" fill="#000">Full Adder</text>
        <text x="300" y="120" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" fill="#666">FA₁</text>
        <!-- Input connections -->
        <line x1="280" y1="80" x2="280" y2="90" stroke="#000" stroke-width="2"/>
        <line x1="320" y1="80" x2="320" y2="90" stroke="#000" stroke-width="2"/>
        <!-- Sum output -->
        <line x1="300" y1="150" x2="300" y2="180" stroke="#000" stroke-width="2"/>
        <rect x="296" y="180" width="8" height="8" fill="#e74c3c" stroke="#c0392b" stroke-width="1" id="rc-s1-pin"/>
        <text x="300" y="200" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#000">S₁</text>
        <!-- Carry chain -->
        <line x1="250" y1="115" x2="150" y2="115" stroke="#f39c12" stroke-width="3"/>
    </g>
    
    <!-- FA0 (LSB) -->
    <g id="rc-fa0">
        <rect x="350" y="80" width="100" height="70" fill="#fff8dc" stroke="#4a90e2" stroke-width="2" rx="5"/>
        <text x="400" y="105" text-anchor="middle" font-family="Arial, sans-serif" font-size="12" fill="#000">Full Adder</text>
        <text x="400" y="120" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" fill="#666">FA₀</text>
        <!-- Input connections -->
        <line x1="380" y1="80" x2="380" y2="90" stroke="#000" stroke-width="2"/>
        <line x1="420" y1="80" x2="420" y2="90" stroke="#000" stroke-width="2"/>
        <!-- Sum output -->
        <line x1="400" y1="150" x2="400" y2="180" stroke="#000" stroke-width="2"/>
        <rect x="396" y="180" width="8" height="8" fill="#e74c3c" stroke="#c0392b" stroke-width="1" id="rc-s0-pin"/>
        <text x="400" y="200" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#000">S₀</text>
        <!-- Carry chain -->
        <line x1="350" y1="115" x2="250" y2="115" stroke="#f39c12" stroke-width="3"/>
        <!-- Carry in -->
        <line x1="450" y1="115" x2="480" y2="115" stroke="#f39c12" stroke-width="3"/>
        <rect x="480" y="111" width="8" height="8" fill="#4a90e2" stroke="#2c5aa0" stroke-width="1" id="rc-cin-pin"/>
        <text x="495" y="118" font-family="Arial, sans-serif" font-size="11" fill="#000">Cin</text>
    </g>
    
    <!-- Final carry output -->
    <line x1="30" y1="115" x2="10" y2="115" stroke="#f39c12" stroke-width="3"/>
    <rect x="2" y="111" width="8" height="8" fill="#e74c3c" stroke="#c0392b" stroke-width="1" id="rc-cout-pin"/>
    <text x="5" y="105" font-family="Arial, sans-serif" font-size="10" fill="#000">Cout</text>
    
    <!-- Carry chain labels -->
    <text x="65" y="110" font-family="Arial, sans-serif" font-size="8" fill="#f39c12">C₂</text>
    <text x="165" y="110" font-family="Arial, sans-serif" font-size="8" fill="#f39c12">C₁</text>
    <text x="265" y="110" font-family="Arial, sans-serif" font-size="8" fill="#f39c12">C₀</text>
    
    <!-- Direction arrow -->
    <path d="M 500 250 L 450 250" stroke="#666" stroke-width="2" marker-end="url(#arrowhead)"/>
    <text x="475" y="245" text-anchor="middle" font-family="Arial, sans-serif" font-size="10" fill="#666">MSB → LSB</text>
    
    <!-- Result display area -->
    <rect x="150" y="250" width="200" height="50" fill="#f0f8ff" stroke="#4a90e2" stroke-width="2" rx="5"/>
    <text x="250" y="270" text-anchor="middle" font-family="Arial, sans-serif" font-size="12" fill="#000">Result</text>
    <text x="250" y="285" text-anchor="middle" font-family="monospace" font-size="14" fill="#000" id="rc-result-display">0000 (0)</text>
    
    <!-- Arrow marker definition -->
    <defs>
        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" fill="#666"/>
        </marker>
    </defs>
</svg>
                            
                        </div>
                        
                        <h4>Timing Analysis</h4>
                        <p>Critical Path: <span id="critical-path">4 gate delays</span></p>
                        <p>Propagation Pattern: C₀ → C₁ → C₂ → C₃ → Cout</p>
                        <p><small>Each full-adder adds 1 gate delay to the carry chain.</small></p>
                    </div>
                </div>
            </div>
        </section>
        
        <!-- Section 4: Knowledge Assessment Quiz -->
        <section class="section" id="assessment-section">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Knowledge Assessment</h2>
                </div>
                
                <p>Test your understanding of arithmetic circuits with this interactive quiz. You need to answer 6 out of 7 questions correctly to pass.</p>
                
                <div id="quiz-container" class="quiz-container">
                    <!-- Quiz will be populated by JavaScript -->
                    <p style="text-align: center; color: #64748b; padding: 40px;">
                        Quiz will load here when JavaScript is initialized
                    </p>
                </div>
            </div>
        </section>
    </main>
</body>
<script>
    window.MODULE_ID = 'arithmetic';
    /**
 * CSC210 Module Shared Utilities
 * Version: 1.0.0
 * 
 * This JavaScript library provides common utilities and functions
 * used across all CSC210 learning modules.
 */

/* ===== PLATFORM COMMUNICATION ===== */
class PlatformCommunication {
    constructor(moduleId) {
        this.moduleId = moduleId;
        this.messageQueue = [];
        this.isInitialized = false;
        
        this.setupMessageListener();
        this.sendModuleLoaded();
    }
    
    setupMessageListener() {
        window.addEventListener('message', (event) => {
            this.handlePlatformMessage(event.data);
        });
    }
    
    handlePlatformMessage(data) {
        switch (data.type) {
            case 'themeUpdate':
                this.handleThemeUpdate(data.theme);
                break;
            case 'pauseModule':
                this.handlePause();
                break;
            case 'resumeModule':
                this.handleResume();
                break;
            case 'resetModule':
                this.handleReset();
                break;
            case 'prerequisiteStatus':
                this.handlePrerequisiteStatus(data);
                break;
        }
    }
    
    sendModuleLoaded() {
        this.sendMessage({
            type: 'moduleLoaded',
            module: this.moduleId,
            version: '1.0.0',
            timestamp: new Date().toISOString()
        });
        this.isInitialized = true;
    }
    
    sendProgress(progress, section = null) {
        this.sendMessage({
            type: 'moduleProgress',
            module: this.moduleId,
            progress: Math.round(progress),
            section: section,
            timestamp: new Date().toISOString()
        });
    }
    
    sendCompletion(completionData = {}) {
        this.sendMessage({
            type: 'moduleComplete',
            module: this.moduleId,
            completionData: {
                timeSpent: completionData.timeSpent || 0,
                quizScore: completionData.quizScore || 0,
                sectionsCompleted: completionData.sectionsCompleted || [],
                ...completionData
            },
            timestamp: new Date().toISOString()
        });
    }
    
    sendError(error, context = {}) {
        this.sendMessage({
            type: 'moduleError',
            module: this.moduleId,
            error: {
                message: error.message || error,
                stack: error.stack,
                context: context
            },
            timestamp: new Date().toISOString()
        });
    }
    
    sendNotification(message, type = 'info') {
        this.sendMessage({
            type: 'notification',
            module: this.moduleId,
            message: message,
            notificationType: type,
            timestamp: new Date().toISOString()
        });
    }
    
    checkPrerequisites(requiredModules = []) {
        this.sendMessage({
            type: 'checkPrerequisites',
            required: requiredModules
        });
    }
    
    sendMessage(data) {
        try {
            window.parent.postMessage(data, '*');
        } catch (error) {
            console.warn('Failed to send message to parent:', error);
            this.messageQueue.push(data);
        }
    }
    
    // Event handlers that modules can override
    handleThemeUpdate(theme) {
        // Override in module if needed
        console.log('Theme updated:', theme);
    }
    
    handlePause() {
        // Override in module to pause animations, timers, etc.
        console.log('Module paused');
    }
    
    handleResume() {
        // Override in module to resume animations, timers, etc.
        console.log('Module resumed');
    }
    
    handleReset() {
        // Override in module to reset all progress
        console.log('Module reset requested');
    }
    
    handlePrerequisiteStatus(data) {
        // Override in module to handle prerequisite validation
        console.log('Prerequisite status:', data);
    }
}

/* ===== PROGRESS TRACKING ===== */
class ProgressTracker {
    constructor(moduleId, sections = []) {
        this.moduleId = moduleId;
        this.sections = sections;
        this.sectionProgress = new Array(sections.length).fill(0);
        this.currentSection = 0;
        this.startTime = Date.now();
        
        this.communication = new PlatformCommunication(moduleId);
    }
    
    updateSectionProgress(sectionIndex, progress) {
        if (sectionIndex >= 0 && sectionIndex < this.sections.length) {
            this.sectionProgress[sectionIndex] = Math.max(0, Math.min(100, progress));
            
            const totalProgress = this.getTotalProgress();
            const sectionName = this.sections[sectionIndex];
            
            this.communication.sendProgress(totalProgress, sectionName);
            this.updateProgressBar(totalProgress);
        }
    }
    
    completeSection(sectionIndex) {
        this.updateSectionProgress(sectionIndex, 100);
        
        // Auto-advance to next section if available
        if (sectionIndex + 1 < this.sections.length) {
            this.currentSection = sectionIndex + 1;
        }
    }
    
    getTotalProgress() {
        const sum = this.sectionProgress.reduce((a, b) => a + b, 0);
        return Math.round(sum / this.sections.length);
    }
    
    getTimeSpent() {
        return Math.round((Date.now() - this.startTime) / 1000);
    }
    
    updateProgressBar(progress) {
        const progressBar = document.getElementById('module-progress');
        const progressText = document.getElementById('progress-text');
        
        if (progressBar) {
            progressBar.style.width = progress + '%';
            progressBar.setAttribute('aria-valuenow', progress);
        }
        
        if (progressText) {
            progressText.textContent = progress + '%';
        }
    }
    
    markComplete(additionalData = {}) {
        const completionData = {
            timeSpent: this.getTimeSpent(),
            sectionsCompleted: this.sections,
            finalProgress: this.getTotalProgress(),
            ...additionalData
        };
        
        this.communication.sendCompletion(completionData);
    }
}

/* ===== QUIZ SYSTEM ===== */
class QuizManager {
    constructor(quizData, passingScore = 80) {
        this.questions = quizData;
        this.currentQuestion = 0;
        this.answers = {};
        this.passingScore = passingScore;
        this.completed = false;
        
        this.setupQuizInterface();
    }
    
    setupQuizInterface() {
        const container = document.getElementById('quiz-container');
        if (!container) return;
        
        this.renderQuestion();
    }
    
    renderQuestion() {
        const container = document.getElementById('quiz-container');
        const question = this.questions[this.currentQuestion];
        
        container.innerHTML = `
            <div class="quiz-question">
                <div class="quiz-header">
                    <h3>Question ${this.currentQuestion + 1} of ${this.questions.length}</h3>
                    <div class="quiz-progress">
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${(this.currentQuestion / this.questions.length) * 100}%"></div>
                        </div>
                    </div>
                </div>
                
                <div class="question-content">
                    <h4>${question.question}</h4>
                    
                    <div class="quiz-options" role="radiogroup" aria-labelledby="question-${this.currentQuestion}">
                        ${question.options.map((option, index) => `
                            <div class="quiz-option">
                                <label>
                                    <input type="radio" 
                                           name="question-${this.currentQuestion}" 
                                           value="${index}"
                                           onchange="quizManager.selectAnswer(${index})"
                                           aria-describedby="option-${this.currentQuestion}-${index}">
                                    <span id="option-${this.currentQuestion}-${index}">${option}</span>
                                </label>
                            </div>
                        `).join('')}
                    </div>
                    
                    <div class="quiz-feedback" id="feedback-${this.currentQuestion}"></div>
                </div>
                
                <div class="quiz-actions">
                    <button class="btn btn-secondary" onclick="quizManager.previousQuestion()" 
                            ${this.currentQuestion === 0 ? 'disabled' : ''}>
                        Previous
                    </button>
                    
                    <button class="btn btn-primary" onclick="quizManager.checkAnswer()" 
                            id="check-answer-btn" disabled>
                        Check Answer
                    </button>
                    
                    <button class="btn btn-primary" onclick="quizManager.nextQuestion()" 
                            id="next-question-btn" style="display: none;">
                        ${this.currentQuestion === this.questions.length - 1 ? 'Finish Quiz' : 'Next Question'}
                    </button>
                </div>
            </div>
        `;
    }
    
    selectAnswer(answerIndex) {
        this.answers[this.currentQuestion] = answerIndex;
        document.getElementById('check-answer-btn').disabled = false;
    }
    
    checkAnswer() {
        const question = this.questions[this.currentQuestion];
        const userAnswer = this.answers[this.currentQuestion];
        const isCorrect = userAnswer === question.correct;
        
        const feedback = document.getElementById(`feedback-${this.currentQuestion}`);
        feedback.className = `quiz-feedback ${isCorrect ? 'correct' : 'incorrect'}`;
        feedback.style.display = 'block';
        feedback.innerHTML = `
            <strong>${isCorrect ? 'Correct!' : 'Incorrect.'}</strong>
            <p>${question.explanation || (isCorrect ? 'Well done!' : 'Please review the material and try again.')}</p>
        `;
        
        // Disable answer options and show next button
        const options = document.querySelectorAll(`input[name="question-${this.currentQuestion}"]`);
        options.forEach(option => option.disabled = true);
        
        document.getElementById('check-answer-btn').style.display = 'none';
        document.getElementById('next-question-btn').style.display = 'inline-block';
        
        // Announce result for screen readers
        this.announceToScreenReader(isCorrect ? 'Correct answer' : 'Incorrect answer');
    }
    
    nextQuestion() {
        if (this.currentQuestion < this.questions.length - 1) {
            this.currentQuestion++;
            this.renderQuestion();
        } else {
            this.completeQuiz();
        }
    }
    
    previousQuestion() {
        if (this.currentQuestion > 0) {
            this.currentQuestion--;
            this.renderQuestion();
        }
    }
    
    completeQuiz() {
        const score = this.calculateScore();
        const passed = score >= this.passingScore;
        
        this.completed = true;
        this.displayResults(score, passed);
        
        return { score, passed };
    }
    
    calculateScore() {
        const correctAnswers = this.questions.reduce((count, question, index) => {
            return count + (this.answers[index] === question.correct ? 1 : 0);
        }, 0);
        
        return Math.round((correctAnswers / this.questions.length) * 100);
    }
    
    displayResults(score, passed) {
        const container = document.getElementById('quiz-container');
        
        container.innerHTML = `
            <div class="quiz-results">
                <div class="results-header">
                    <h3>Quiz Complete!</h3>
                    <div class="score-display ${passed ? 'passed' : 'failed'}">
                        <div class="score-circle">
                            <span class="score-number">${score}%</span>
                        </div>
                        <p class="score-status">
                            ${passed ? `Congratulations! You passed with ${score}%.` : `You scored ${score}%. You need ${this.passingScore}% to pass.`}
                        </p>
                    </div>
                </div>
                
                <div class="results-breakdown">
                    <h4>Question Breakdown:</h4>
                    <div class="question-summary">
                        ${this.questions.map((question, index) => {
                            const isCorrect = this.answers[index] === question.correct;
                            return `
                                <div class="question-item ${isCorrect ? 'correct' : 'incorrect'}">
                                    <span class="question-number">Q${index + 1}</span>
                                    <span class="question-status">${isCorrect ? '✓' : '✗'}</span>
                                    <span class="question-text">${question.question.substring(0, 50)}...</span>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
                
                <div class="results-actions">
                    ${!passed ? `
                        <button class="btn btn-primary" onclick="quizManager.retakeQuiz()">
                            Retake Quiz
                        </button>
                    ` : ''}
                    <button class="btn btn-secondary" onclick="quizManager.reviewAnswers()">
                        Review Answers
                    </button>
                </div>
            </div>
        `;
        
        // Announce completion for screen readers
        this.announceToScreenReader(`Quiz completed. Score: ${score} percent. ${passed ? 'Passed' : 'Failed'}.`);
    }
    
    retakeQuiz() {
        this.currentQuestion = 0;
        this.answers = {};
        this.completed = false;
        this.renderQuestion();
    }
    
    reviewAnswers() {
        // Implementation for reviewing answers
        console.log('Review answers functionality');
    }
    
    announceToScreenReader(message) {
        const announcement = document.createElement('div');
        announcement.setAttribute('aria-live', 'polite');
        announcement.setAttribute('aria-atomic', 'true');
        announcement.className = 'sr-only';
        announcement.textContent = message;
        
        document.body.appendChild(announcement);
        
        setTimeout(() => {
            document.body.removeChild(announcement);
        }, 1000);
    }
}

/* ===== ERROR HANDLING ===== */
class ErrorHandler {
    constructor(moduleId) {
        this.moduleId = moduleId;
        this.errors = [];
        this.setupGlobalErrorHandling();
    }
    
    setupGlobalErrorHandling() {
        window.addEventListener('error', (event) => {
            this.handleError(event.error, {
                filename: event.filename,
                line: event.lineno,
                column: event.colno
            });
        });
        
        window.addEventListener('unhandledrejection', (event) => {
            this.handleError(event.reason, {
                type: 'unhandled_promise_rejection'
            });
        });
    }
    
    handleError(error, context = {}) {
        const errorInfo = {
            message: error.message || error,
            stack: error.stack,
            context: context,
            timestamp: new Date().toISOString(),
            moduleId: this.moduleId
        };
        
        this.errors.push(errorInfo);
        
        // Log to console for debugging
        console.error('Module Error:', errorInfo);
        
        // Send to platform if it's a critical error
        if (this.isCriticalError(error)) {
            const communication = new PlatformCommunication(this.moduleId);
            communication.sendError(error, context);
        }
        
        // Show user-friendly error message
        this.showUserError(error, context);
    }
    
    isCriticalError(error) {
        const criticalKeywords = [
            'simulator',
            'calculation',
            'postMessage',
            'undefined is not a function',
            'cannot read property',
            'network error'
        ];
        
        const errorMessage = (error.message || error).toLowerCase();
        return criticalKeywords.some(keyword => errorMessage.includes(keyword));
    }
    
    showUserError(error, context = {}) {
        const errorContainer = document.getElementById('error-container') || this.createErrorContainer();
        
        const errorElement = document.createElement('div');
        errorElement.className = 'error-notification';
        errorElement.innerHTML = `
            <div class="error-content">
                <strong>⚠️ Something went wrong</strong>
                <p>We encountered an issue with the simulator. Please try refreshing the page.</p>
                <button class="btn btn-small btn-secondary" onclick="this.parentElement.parentElement.remove()">
                    Dismiss
                </button>
            </div>
        `;
        
        errorContainer.appendChild(errorElement);
        
        // Auto-remove after 10 seconds
        setTimeout(() => {
            if (errorElement.parentElement) {
                errorElement.remove();
            }
        }, 10000);
    }
    
    createErrorContainer() {
        const container = document.createElement('div');
        container.id = 'error-container';
        container.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            max-width: 400px;
        `;
        
        document.body.appendChild(container);
        return container;
    }
    
    getErrors() {
        return this.errors;
    }
    
    clearErrors() {
        this.errors = [];
    }
}

/* ===== UTILITY FUNCTIONS ===== */
const Utils = {
    // Debounce function for performance optimization
    debounce(func, wait, immediate = false) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                timeout = null;
                if (!immediate) func(...args);
            };
            const callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) func(...args);
        };
    },
    
    // Throttle function for performance optimization
    throttle(func, limit) {
        let inThrottle;
        return function(...args) {
            if (!inThrottle) {
                func.apply(this, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    },
    
    // Binary conversion utilities
    binary: {
        toBinary(decimal, bits = 4) {
            return decimal.toString(2).padStart(bits, '0');
        },
        
        toDecimal(binary) {
            return parseInt(binary, 2);
        },
        
        toHex(decimal) {
            return decimal.toString(16).toUpperCase().padStart(2, '0');
        }
    },
    
    // Boolean algebra utilities
    boolean: {
        and(a, b) {
            return a && b;
        },
        
        or(a, b) {
            return a || b;
        },
        
        not(a) {
            return !a;
        },
        
        xor(a, b) {
            return a !== b;
        },
        
        nand(a, b) {
            return !(a && b);
        },
        
        nor(a, b) {
            return !(a || b);
        }
    },
    
    // Animation utilities
    animation: {
        easeInOut(t) {
            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        },
        
        animate(element, properties, duration = 300, easing = this.easeInOut) {
            const startTime = performance.now();
            const startValues = {};
            
            // Get initial values
            Object.keys(properties).forEach(prop => {
                const computedStyle = window.getComputedStyle(element);
                startValues[prop] = parseFloat(computedStyle[prop]) || 0;
            });
            
            function step(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easedProgress = easing(progress);
                
                Object.keys(properties).forEach(prop => {
                    const startValue = startValues[prop];
                    const endValue = properties[prop];
                    const currentValue = startValue + (endValue - startValue) * easedProgress;
                    
                    element.style[prop] = currentValue + (prop.includes('opacity') ? '' : 'px');
                });
                
                if (progress < 1) {
                    requestAnimationFrame(step);
                }
            }
            
            requestAnimationFrame(step);
        }
    },
    
    // Local storage utilities (fallback for platforms that don't support it)
    storage: {
        set(key, value) {
            try {
                localStorage.setItem(key, JSON.stringify(value));
                return true;
            } catch (e) {
                console.warn('Local storage not available, using memory storage');
                this._memoryStorage = this._memoryStorage || {};
                this._memoryStorage[key] = value;
                return false;
            }
        },
        
        get(key) {
            try {
                const item = localStorage.getItem(key);
                return item ? JSON.parse(item) : null;
            } catch (e) {
                return this._memoryStorage ? this._memoryStorage[key] : null;
            }
        },
        
        remove(key) {
            try {
                localStorage.removeItem(key);
            } catch (e) {
                if (this._memoryStorage) {
                    delete this._memoryStorage[key];
                }
            }
        }
    },
    
    // Accessibility utilities
    accessibility: {
        announceToScreenReader(message) {
            const announcement = document.createElement('div');
            announcement.setAttribute('aria-live', 'polite');
            announcement.setAttribute('aria-atomic', 'true');
            announcement.className = 'sr-only';
            announcement.textContent = message;
            
            document.body.appendChild(announcement);
            
            setTimeout(() => {
                if (announcement.parentElement) {
                    document.body.removeChild(announcement);
                }
            }, 1000);
        },
        
        manageFocus(element) {
            if (element) {
                element.focus();
                element.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        },
        
        trapFocus(container) {
            const focusableElements = container.querySelectorAll(
                'a, button, input, textarea, select, details, [tabindex]:not([tabindex="-1"])'
            );
            
            const firstFocusable = focusableElements[0];
            const lastFocusable = focusableElements[focusableElements.length - 1];
            
            container.addEventListener('keydown', (e) => {
                if (e.key === 'Tab') {
                    if (e.shiftKey) {
                        if (document.activeElement === firstFocusable) {
                            lastFocusable.focus();
                            e.preventDefault();
                        }
                    } else {
                        if (document.activeElement === lastFocusable) {
                            firstFocusable.focus();
                            e.preventDefault();
                        }
                    }
                }
            });
        }
    },
    
    // Performance utilities
    performance: {
        measureFunction(func, name = 'Function') {
            return function(...args) {
                const start = performance.now();
                const result = func.apply(this, args);
                const end = performance.now();
                console.log(`${name} took ${end - start} milliseconds.`);
                return result;
            };
        },
        
        fps: {
            counter: 0,
            lastTime: 0,
            
            start() {
                this.lastTime = performance.now();
                this.counter = 0;
                this.measure();
            },
            
            measure() {
                this.counter++;
                const currentTime = performance.now();
                
                if (currentTime - this.lastTime >= 1000) {
                    console.log(`FPS: ${this.counter}`);
                    this.counter = 0;
                    this.lastTime = currentTime;
                }
                
                requestAnimationFrame(() => this.measure());
            }
        }
    }
};

/* ===== VALIDATION UTILITIES ===== */
class Validator {
    static validateBinaryInput(input, bits = 4) {
        const binaryPattern = new RegExp(`^[01]{1,${bits}});
        return binaryPattern.test(input);
    }
    
    static validateDecimalInput(input, max = 15) {
        const num = parseInt(input);
        return !isNaN(num) && num >= 0 && num <= max;
    }
    
    static validateEmail(email) {
        const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailPattern.test(email);
    }
    
    static sanitizeInput(input) {
        return input.replace(/[<>&"']/g, (match) => {
            const entities = {
                '<': '&lt;',
                '>': '&gt;',
                '&': '&amp;',
                '"': '&quot;',
                "'": '&#39;'
            };
            return entities[match];
        });
    }
}

/* ===== EXPORT FOR MODULE USAGE ===== */
// Make utilities available globally for module usage
window.ModuleUtils = {
    PlatformCommunication,
    ProgressTracker,
    QuizManager,
    ErrorHandler,
    Utils,
    Validator
};

// Initialize error handling for all modules
window.addEventListener('DOMContentLoaded', () => {
    // Auto-initialize error handling if moduleId is defined
    if (typeof window.MODULE_ID !== 'undefined') {
        window.errorHandler = new ErrorHandler(window.MODULE_ID);
    }
});

// Export for ES6 modules if supported
if (typeof module !== 'undefined' && module.exports) {
    module.exports = window.ModuleUtils;
}
    /**
 * CSC210 Circuit Simulation Library
 * Version: 1.0.0
 * 
 * This library provides interactive circuit simulation capabilities
 * for all CSC210 learning modules, including logic gates, truth tables,
 * and visual circuit representations.
 */

/* ===== BASE CLASSES ===== */

/**
 * Base class for all circuit components
 */
class CircuitComponent {
    constructor(id, type, x = 0, y = 0) {
        this.id = id;
        this.type = type;
        this.x = x;
        this.y = y;
        this.inputs = [];
        this.outputs = [];
        this.selected = false;
        this.width = 60;
        this.height = 40;
    }
    
    addInput(input) {
        this.inputs.push(input);
    }
    
    addOutput(output) {
        this.outputs.push(output);
    }
    
    getBoundingBox() {
        return {
            left: this.x - this.width / 2,
            right: this.x + this.width / 2,
            top: this.y - this.height / 2,
            bottom: this.y + this.height / 2
        };
    }
    
    containsPoint(x, y) {
        const bbox = this.getBoundingBox();
        return x >= bbox.left && x <= bbox.right && y >= bbox.top && y <= bbox.bottom;
    }
    
    // Abstract methods to be implemented by subclasses
    compute() {
        throw new Error('compute() method must be implemented by subclass');
    }
    
    draw(ctx) {
        throw new Error('draw() method must be implemented by subclass');
    }
}

/**
 * Connection between circuit components
 */
class CircuitConnection {
    constructor(fromComponent, fromOutput, toComponent, toInput) {
        this.from = fromComponent;
        this.fromOutput = fromOutput;
        this.to = toComponent;
        this.toInput = toInput;
        this.value = false;
        this.animated = false;
    }
    
    draw(ctx, animated = false) {
        const fromPos = this.getOutputPosition();
        const toPos = this.getInputPosition();
        
        ctx.strokeStyle = this.value ? '#059669' : '#64748b';
        ctx.lineWidth = this.value && animated ? 3 : 2;
        ctx.beginPath();
        
        // Draw curved connection line
        const controlPoint1X = fromPos.x + (toPos.x - fromPos.x) * 0.5;
        const controlPoint1Y = fromPos.y;
        const controlPoint2X = fromPos.x + (toPos.x - fromPos.x) * 0.5;
        const controlPoint2Y = toPos.y;
        
        ctx.moveTo(fromPos.x, fromPos.y);
        ctx.bezierCurveTo(controlPoint1X, controlPoint1Y, controlPoint2X, controlPoint2Y, toPos.x, toPos.y);
        ctx.stroke();
        
        // Draw signal flow animation if active
        if (this.value && animated) {
            this.drawSignalFlow(ctx, fromPos, toPos);
        }
    }
    
    drawSignalFlow(ctx, fromPos, toPos) {
        const time = Date.now() / 1000;
        const progress = (time * 2) % 1; // 2 signals per second
        
        const x = fromPos.x + (toPos.x - fromPos.x) * progress;
        const y = fromPos.y + (toPos.y - fromPos.y) * progress;
        
        ctx.fillStyle = '#f59e0b';
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, 2 * Math.PI);
        ctx.fill();
    }
    
    getOutputPosition() {
        return {
            x: this.from.x + this.from.width / 2,
            y: this.from.y
        };
    }
    
    getInputPosition() {
        return {
            x: this.to.x - this.to.width / 2,
            y: this.to.y
        };
    }
}

/* ===== LOGIC GATES ===== */

/**
 * AND Gate implementation
 */
class ANDGate extends CircuitComponent {
    constructor(id, x = 0, y = 0) {
        super(id, 'AND', x, y);
        this.inputs = [false, false];
        this.output = false;
    }
    
    compute() {
        this.output = this.inputs[0] && this.inputs[1];
        return this.output;
    }
    
    draw(ctx) {
        const bbox = this.getBoundingBox();
        
        // Draw gate body
        ctx.fillStyle = this.selected ? '#e2e8f0' : '#f8fafc';
        ctx.strokeStyle = this.selected ? '#2563eb' : '#64748b';
        ctx.lineWidth = this.selected ? 2 : 1;
        
        ctx.beginPath();
        ctx.roundRect(bbox.left, bbox.top, this.width, this.height, 5);
        ctx.fill();
        ctx.stroke();
        
        // Draw label
        ctx.fillStyle = '#1e293b';
        ctx.font = '12px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('AND', this.x, this.y + 4);
        
        // Draw input/output pins
        this.drawPins(ctx);
    }
    
    drawPins(ctx) {
        const bbox = this.getBoundingBox();
        
        // Input pins
        ctx.fillStyle = this.inputs[0] ? '#059669' : '#64748b';
        ctx.beginPath();
        ctx.arc(bbox.left, this.y - 8, 3, 0, 2 * Math.PI);
        ctx.fill();
        
        ctx.fillStyle = this.inputs[1] ? '#059669' : '#64748b';
        ctx.beginPath();
        ctx.arc(bbox.left, this.y + 8, 3, 0, 2 * Math.PI);
        ctx.fill();
        
        // Output pin
        ctx.fillStyle = this.output ? '#059669' : '#64748b';
        ctx.beginPath();
        ctx.arc(bbox.right, this.y, 3, 0, 2 * Math.PI);
        ctx.fill();
    }
}

/**
 * OR Gate implementation
 */
class ORGate extends CircuitComponent {
    constructor(id, x = 0, y = 0) {
        super(id, 'OR', x, y);
        this.inputs = [false, false];
        this.output = false;
    }
    
    compute() {
        this.output = this.inputs[0] || this.inputs[1];
        return this.output;
    }
    
    draw(ctx) {
        const bbox = this.getBoundingBox();
        
        ctx.fillStyle = this.selected ? '#e2e8f0' : '#f8fafc';
        ctx.strokeStyle = this.selected ? '#2563eb' : '#64748b';
        ctx.lineWidth = this.selected ? 2 : 1;
        
        ctx.beginPath();
        ctx.roundRect(bbox.left, bbox.top, this.width, this.height, 5);
        ctx.fill();
        ctx.stroke();
        
        ctx.fillStyle = '#1e293b';
        ctx.font = '12px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('OR', this.x, this.y + 4);
        
        this.drawPins(ctx);
    }
    
    drawPins(ctx) {
        const bbox = this.getBoundingBox();
        
        // Input pins
        ctx.fillStyle = this.inputs[0] ? '#059669' : '#64748b';
        ctx.beginPath();
        ctx.arc(bbox.left, this.y - 8, 3, 0, 2 * Math.PI);
        ctx.fill();
        
        ctx.fillStyle = this.inputs[1] ? '#059669' : '#64748b';
        ctx.beginPath();
        ctx.arc(bbox.left, this.y + 8, 3, 0, 2 * Math.PI);
        ctx.fill();
        
        // Output pin
        ctx.fillStyle = this.output ? '#059669' : '#64748b';
        ctx.beginPath();
        ctx.arc(bbox.right, this.y, 3, 0, 2 * Math.PI);
        ctx.fill();
    }
}

/**
 * XOR Gate implementation
 */
class XORGate extends CircuitComponent {
    constructor(id, x = 0, y = 0) {
        super(id, 'XOR', x, y);
        this.inputs = [false, false];
        this.output = false;
    }
    
    compute() {
        this.output = this.inputs[0] !== this.inputs[1];
        return this.output;
    }
    
    draw(ctx) {
        const bbox = this.getBoundingBox();
        
        ctx.fillStyle = this.selected ? '#e2e8f0' : '#f8fafc';
        ctx.strokeStyle = this.selected ? '#2563eb' : '#64748b';
        ctx.lineWidth = this.selected ? 2 : 1;
        
        ctx.beginPath();
        ctx.roundRect(bbox.left, bbox.top, this.width, this.height, 5);
        ctx.fill();
        ctx.stroke();
        
        ctx.fillStyle = '#1e293b';
        ctx.font = '12px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('XOR', this.x, this.y + 4);
        
        this.drawPins(ctx);
    }
    
    drawPins(ctx) {
        const bbox = this.getBoundingBox();
        
        // Input pins
        ctx.fillStyle = this.inputs[0] ? '#059669' : '#64748b';
        ctx.beginPath();
        ctx.arc(bbox.left, this.y - 8, 3, 0, 2 * Math.PI);
        ctx.fill();
        
        ctx.fillStyle = this.inputs[1] ? '#059669' : '#64748b';
        ctx.beginPath();
        ctx.arc(bbox.left, this.y + 8, 3, 0, 2 * Math.PI);
        ctx.fill();
        
        // Output pin
        ctx.fillStyle = this.output ? '#059669' : '#64748b';
        ctx.beginPath();
        ctx.arc(bbox.right, this.y, 3, 0, 2 * Math.PI);
        ctx.fill();
    }
}

/**
 * NOT Gate implementation
 */
class NOTGate extends CircuitComponent {
    constructor(id, x = 0, y = 0) {
        super(id, 'NOT', x, y);
        this.inputs = [false];
        this.output = false;
        this.width = 50;
    }
    
    compute() {
        this.output = !this.inputs[0];
        return this.output;
    }
    
    draw(ctx) {
        const bbox = this.getBoundingBox();
        
        ctx.fillStyle = this.selected ? '#e2e8f0' : '#f8fafc';
        ctx.strokeStyle = this.selected ? '#2563eb' : '#64748b';
        ctx.lineWidth = this.selected ? 2 : 1;
        
        ctx.beginPath();
        ctx.roundRect(bbox.left, bbox.top, this.width, this.height, 5);
        ctx.fill();
        ctx.stroke();
        
        ctx.fillStyle = '#1e293b';
        ctx.font = '12px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('NOT', this.x, this.y + 4);
        
        this.drawPins(ctx);
    }
    
    drawPins(ctx) {
        const bbox = this.getBoundingBox();
        
        // Input pin
        ctx.fillStyle = this.inputs[0] ? '#059669' : '#64748b';
        ctx.beginPath();
        ctx.arc(bbox.left, this.y, 3, 0, 2 * Math.PI);
        ctx.fill();
        
        // Output pin
        ctx.fillStyle = this.output ? '#059669' : '#64748b';
        ctx.beginPath();
        ctx.arc(bbox.right, this.y, 3, 0, 2 * Math.PI);
        ctx.fill();
    }
}

/* ===== INPUT/OUTPUT COMPONENTS ===== */

/**
 * Input component for circuit simulation
 */
class InputComponent extends CircuitComponent {
    constructor(id, label = 'IN', x = 0, y = 0) {
        super(id, 'INPUT', x, y);
        this.label = label;
        this.value = false;
        this.width = 40;
    }
    
    compute() {
        return this.value;
    }
    
    toggle() {
        this.value = !this.value;
        return this.value;
    }
    
    draw(ctx) {
        const bbox = this.getBoundingBox();
        
        ctx.fillStyle = this.value ? '#059669' : '#f8fafc';
        ctx.strokeStyle = this.value ? '#047857' : '#64748b';
        ctx.lineWidth = 2;
        
        ctx.beginPath();
        ctx.roundRect(bbox.left, bbox.top, this.width, this.height, 5);
        ctx.fill();
        ctx.stroke();
        
        ctx.fillStyle = this.value ? 'white' : '#1e293b';
        ctx.font = 'bold 10px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(this.label, this.x, this.y - 2);
        ctx.fillText(this.value ? '1' : '0', this.x, this.y + 10);
        
        // Output pin
        ctx.fillStyle = this.value ? '#059669' : '#64748b';
        ctx.beginPath();
        ctx.arc(bbox.right, this.y, 3, 0, 2 * Math.PI);
        ctx.fill();
    }
}

/**
 * Output component for circuit simulation
 */
class OutputComponent extends CircuitComponent {
    constructor(id, label = 'OUT', x = 0, y = 0) {
        super(id, 'OUTPUT', x, y);
        this.label = label;
        this.value = false;
        this.width = 50;
    }
    
    compute() {
        // Output components don't compute, they display
        return this.value;
    }
    
    setValue(value) {
        this.value = value;
    }
    
    draw(ctx) {
        const bbox = this.getBoundingBox();
        
        ctx.fillStyle = this.value ? '#059669' : '#f8fafc';
        ctx.strokeStyle = this.value ? '#047857' : '#64748b';
        ctx.lineWidth = 2;
        
        ctx.beginPath();
        ctx.roundRect(bbox.left, bbox.top, this.width, this.height, 5);
        ctx.fill();
        ctx.stroke();
        
        ctx.fillStyle = this.value ? 'white' : '#1e293b';
        ctx.font = 'bold 10px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(this.label, this.x, this.y - 2);
        ctx.fillText(this.value ? '1' : '0', this.x, this.y + 10);
        
        // Input pin
        ctx.fillStyle = this.value ? '#059669' : '#64748b';
        ctx.beginPath();
        ctx.arc(bbox.left, this.y, 3, 0, 2 * Math.PI);
        ctx.fill();
    }
}

/* ===== CIRCUIT SIMULATOR ===== */

/**
 * Main circuit simulator class
 */
class CircuitSimulator {
    constructor(canvasId, options = {}) {
        this.canvas = document.getElementById(canvasId);
        if (!this.canvas) {
            throw new Error(`Canvas element with id "${canvasId}" not found`);
        }
        
        this.ctx = this.canvas.getContext('2d');
        this.components = [];
        this.connections = [];
        this.selectedComponent = null;
        this.isSimulating = false;
        this.animationFrame = null;
        
        // Configuration options
        this.options = {
            enableAnimation: true,
            showGrid: false,
            gridSize: 20,
            allowDrag: true,
            ...options
        };
        
        this.setupCanvas();
        this.setupEventListeners();
    }
    
    setupCanvas() {
        // Set up high-DPI canvas
        const dpr = window.devicePixelRatio || 1;
        const rect = this.canvas.getBoundingClientRect();
        
        this.canvas.width = rect.width * dpr;
        this.canvas.height = rect.height * dpr;
        this.ctx.scale(dpr, dpr);
        
        this.canvas.style.width = rect.width + 'px';
        this.canvas.style.height = rect.height + 'px';
    }
    
    setupEventListeners() {
        this.canvas.addEventListener('click', (e) => this.handleClick(e));
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        
        // Handle window resize
        window.addEventListener('resize', () => this.handleResize());
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => this.handleKeyDown(e));
    }
    
    handleClick(event) {
        const rect = this.canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        // Check if clicking on a component
        const clickedComponent = this.getComponentAt(x, y);
        
        if (clickedComponent) {
            if (clickedComponent.type === 'INPUT') {
                clickedComponent.toggle();
                this.simulate();
                this.render();
            } else {
                this.selectComponent(clickedComponent);
            }
        } else {
            this.selectComponent(null);
        }
    }
    
    handleMouseMove(event) {
        const rect = this.canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        // Update cursor based on what's under mouse
        const component = this.getComponentAt(x, y);
        if (component) {
            this.canvas.style.cursor = component.type === 'INPUT' ? 'pointer' : 'move';
        } else {
            this.canvas.style.cursor = 'default';
        }
    }
    
    handleMouseDown(event) {
        // Implementation for dragging components
        if (this.options.allowDrag) {
            const rect = this.canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            const component = this.getComponentAt(x, y);
            if (component && component.type !== 'INPUT' && component.type !== 'OUTPUT') {
                this.dragging = {
                    component: component,
                    offsetX: x - component.x,
                    offsetY: y - component.y
                };
            }
        }
    }
    
    handleMouseUp(event) {
        if (this.dragging) {
            const rect = this.canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            this.dragging.component.x = x - this.dragging.offsetX;
            this.dragging.component.y = y - this.dragging.offsetY;
            
            this.dragging = null;
            this.render();
        }
    }
    
    handleResize() {
        this.setupCanvas();
        this.render();
    }
    
    handleKeyDown(event) {
        if (event.key === 'Delete' && this.selectedComponent) {
            this.removeComponent(this.selectedComponent.id);
        }
        
        if (event.key === 'Escape') {
            this.selectComponent(null);
        }
    }
    
    getComponentAt(x, y) {
        return this.components.find(component => component.containsPoint(x, y));
    }
    
    selectComponent(component) {
        if (this.selectedComponent) {
            this.selectedComponent.selected = false;
        }
        
        this.selectedComponent = component;
        
        if (component) {
            component.selected = true;
        }
        
        this.render();
    }
    
    // Public API methods
    
    addComponent(type, id, x = 100, y = 100, options = {}) {
        let component;
        
        switch (type.toUpperCase()) {
            case 'AND':
                component = new ANDGate(id, x, y);
                break;
            case 'OR':
                component = new ORGate(id, x, y);
                break;
            case 'XOR':
                component = new XORGate(id, x, y);
                break;
            case 'NOT':
                component = new NOTGate(id, x, y);
                break;
            case 'INPUT':
                component = new InputComponent(id, options.label || 'IN', x, y);
                break;
            case 'OUTPUT':
                component = new OutputComponent(id, options.label || 'OUT', x, y);
                break;
            default:
                throw new Error(`Unknown component type: ${type}`);
        }
        
        this.components.push(component);
        this.render();
        return component;
    }
    
    removeComponent(id) {
        const index = this.components.findIndex(comp => comp.id === id);
        if (index !== -1) {
            // Remove connections involving this component
            this.connections = this.connections.filter(conn => 
                conn.from.id !== id && conn.to.id !== id
            );
            
            this.components.splice(index, 1);
            
            if (this.selectedComponent && this.selectedComponent.id === id) {
                this.selectedComponent = null;
            }
            
            this.render();
        }
    }
    
    connectComponents(fromId, fromOutput, toId, toInput) {
        const fromComponent = this.components.find(c => c.id === fromId);
        const toComponent = this.components.find(c => c.id === toId);
        
        if (fromComponent && toComponent) {
            const connection = new CircuitConnection(fromComponent, fromOutput, toComponent, toInput);
            this.connections.push(connection);
            this.render();
            return connection;
        }
        
        return null;
    }
    
    simulate() {
        // Topological sort to determine simulation order
        const sorted = this.topologicalSort();
        
        // Simulate each component in order
        sorted.forEach(component => {
            if (component.type !== 'INPUT') {
                component.compute();
            }
        });
        
        // Update connections
        this.connections.forEach(connection => {
            connection.value = connection.from.compute();
            
            // Update input of connected component
            if (connection.to.type !== 'OUTPUT') {
                connection.to.inputs[connection.toInput] = connection.value;
            } else {
                connection.to.setValue(connection.value);
            }
        });
    }
    
    topologicalSort() {
        // Simple topological sort for component simulation order
        const visited = new Set();
        const result = [];
        
        const visit = (component) => {
            if (visited.has(component.id)) return;
            
            visited.add(component.id);
            
            // Visit dependencies first (components that feed into this one)
            this.connections
                .filter(conn => conn.to.id === component.id)
                .forEach(conn => visit(conn.from));
            
            result.push(component);
        };
        
        this.components.forEach(component => visit(component));
        
        return result;
    }
    
    startAnimation() {
        if (this.isSimulating) return;
        
        this.isSimulating = true;
        
        const animate = () => {
            if (!this.isSimulating) return;
            
            this.simulate();
            this.render();
            
            this.animationFrame = requestAnimationFrame(animate);
        };
        
        animate();
    }
    
    stopAnimation() {
        this.isSimulating = false;
        if (this.animationFrame) {
            cancelAnimationFrame(this.animationFrame);
            this.animationFrame = null;
        }
    }
    
    render() {
        // Clear canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw grid if enabled
        if (this.options.showGrid) {
            this.drawGrid();
        }
        
        // Draw connections first (behind components)
        this.connections.forEach(connection => {
            connection.draw(this.ctx, this.options.enableAnimation && this.isSimulating);
        });
        
        // Draw components
        this.components.forEach(component => {
            component.draw(this.ctx);
        });
        
        // Draw selection indicator
        if (this.selectedComponent) {
            this.drawSelectionIndicator(this.selectedComponent);
        }
    }
    
    drawGrid() {
        const gridSize = this.options.gridSize;
        const width = this.canvas.width;
        const height = this.canvas.height;
        
        this.ctx.strokeStyle = '#e2e8f0';
        this.ctx.lineWidth = 1;
        
        // Vertical lines
        for (let x = 0; x <= width; x += gridSize) {
            this.ctx.beginPath();
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, height);
            this.ctx.stroke();
        }
        
        // Horizontal lines
        for (let y = 0; y <= height; y += gridSize) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(width, y);
            this.ctx.stroke();
        }
    }
    
    drawSelectionIndicator(component) {
        const bbox = component.getBoundingBox();
        
        this.ctx.strokeStyle = '#2563eb';
        this.ctx.lineWidth = 2;
        this.ctx.setLineDash([5, 5]);
        
        this.ctx.beginPath();
        this.ctx.roundRect(bbox.left - 5, bbox.top - 5, component.width + 10, component.height + 10, 8);
        this.ctx.stroke();
        
        this.ctx.setLineDash([]); // Reset line dash
    }
    
    clear() {
        this.components = [];
        this.connections = [];
        this.selectedComponent = null;
        this.stopAnimation();
        this.render();
    }
    
    getComponentById(id) {
        return this.components.find(c => c.id === id);
    }
    
    exportCircuit() {
        return {
            components: this.components.map(c => ({
                id: c.id,
                type: c.type,
                x: c.x,
                y: c.y,
                value: c.value || c.inputs,
                label: c.label
            })),
            connections: this.connections.map(c => ({
                from: c.from.id,
                fromOutput: c.fromOutput,
                to: c.to.id,
                toInput: c.toInput
            }))
        };
    }
    
    importCircuit(circuitData) {
        this.clear();
        
        // Add components
        circuitData.components.forEach(compData => {
            const component = this.addComponent(compData.type, compData.id, compData.x, compData.y, {
                label: compData.label
            });
            
            if (compData.value !== undefined) {
                if (component.type === 'INPUT') {
                    component.value = compData.value;
                } else {
                    component.inputs = compData.value;
                }
            }
        });
        
        // Add connections
        circuitData.connections.forEach(connData => {
            this.connectComponents(connData.from, connData.fromOutput, connData.to, connData.toInput);
        });
        
        this.render();
    }
}

/* ===== TRUTH TABLE GENERATOR ===== */

/**
 * Utility class for generating and managing truth tables
 */
class TruthTableGenerator {
    static generate(inputs, outputFunction) {
        const numInputs = inputs.length;
        const numRows = Math.pow(2, numInputs);
        const table = [];
        
        for (let i = 0; i < numRows; i++) {
            const row = {};
            
            // Generate input combinations
            inputs.forEach((inputName, index) => {
                row[inputName] = (i >> (numInputs - 1 - index)) & 1;
            });
            
            // Calculate output
            if (typeof outputFunction === 'function') {
                const inputValues = inputs.map(name => row[name]);
                row.output = outputFunction(...inputValues);
            }
            
            table.push(row);
        }
        
        return table;
    }
    
    static renderTable(container, truthTable, options = {}) {
        const table = document.createElement('table');
        table.className = 'truth-table';
        
        // Create header
        const header = table.createTHead();
        const headerRow = header.insertRow();
        
        const inputs = Object.keys(truthTable[0]).filter(key => key !== 'output');
        inputs.forEach(input => {
            const th = document.createElement('th');
            th.textContent = input;
            headerRow.appendChild(th);
        });
        
        if (truthTable[0].hasOwnProperty('output')) {
            const th = document.createElement('th');
            th.textContent = options.outputLabel || 'Output';
            headerRow.appendChild(th);
        }
        
        // Create body
        const tbody = table.createTBody();
        truthTable.forEach((row, index) => {
            const tr = tbody.insertRow();
            tr.setAttribute('data-row', index);
            
            inputs.forEach(input => {
                const td = tr.insertCell();
                td.textContent = row[input];
            });
            
            if (row.hasOwnProperty('output')) {
                const td = tr.insertCell();
                td.textContent = row.output;
            }
        });
        
        // Clear container and add table
        container.innerHTML = '';
        container.appendChild(table);
        
        return table;
    }
    
    static highlightRow(table, rowIndex) {
        // Remove existing highlights
        const rows = table.querySelectorAll('tbody tr');
        rows.forEach(row => row.classList.remove('active-row'));
        
        // Highlight specified row
        if (rowIndex >= 0 && rowIndex < rows.length) {
            rows[rowIndex].classList.add('active-row');
            rows[rowIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }
}

/* ===== SPECIALIZED CIRCUIT COMPONENTS ===== */

/**
 * Half Adder circuit implementation
 */
class HalfAdder extends CircuitComponent {
    constructor(id, x = 0, y = 0) {
        super(id, 'HALF_ADDER', x, y);
        this.width = 80;
        this.height = 60;
        this.inputs = [false, false]; // A, B
        this.outputs = [false, false]; // Sum, Carry
    }
    
    compute() {
        const [a, b] = this.inputs;
        this.outputs[0] = a !== b; // Sum = A XOR B
        this.outputs[1] = a && b;  // Carry = A AND B
        return this.outputs;
    }
    
    draw(ctx) {
        const bbox = this.getBoundingBox();
        
        // Draw component body
        ctx.fillStyle = this.selected ? '#e2e8f0' : '#f8fafc';
        ctx.strokeStyle = this.selected ? '#2563eb' : '#64748b';
        ctx.lineWidth = this.selected ? 2 : 1;
        
        ctx.beginPath();
        ctx.roundRect(bbox.left, bbox.top, this.width, this.height, 8);
        ctx.fill();
        ctx.stroke();
        
        // Draw label
        ctx.fillStyle = '#1e293b';
        ctx.font = 'bold 12px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('HALF', this.x, this.y - 5);
        ctx.fillText('ADDER', this.x, this.y + 8);
        
        // Draw pins with labels
        this.drawHalfAdderPins(ctx);
    }
    
    drawHalfAdderPins(ctx) {
        const bbox = this.getBoundingBox();
        
        // Input pins
        ctx.fillStyle = this.inputs[0] ? '#059669' : '#64748b';
        ctx.beginPath();
        ctx.arc(bbox.left, this.y - 12, 4, 0, 2 * Math.PI);
        ctx.fill();
        
        ctx.fillStyle = '#1e293b';
        ctx.font = '10px monospace';
        ctx.textAlign = 'right';
        ctx.fillText('A', bbox.left - 8, this.y - 8);
        
        ctx.fillStyle = this.inputs[1] ? '#059669' : '#64748b';
        ctx.beginPath();
        ctx.arc(bbox.left, this.y + 12, 4, 0, 2 * Math.PI);
        ctx.fill();
        
        ctx.fillStyle = '#1e293b';
        ctx.fillText('B', bbox.left - 8, this.y + 16);
        
        // Output pins
        ctx.fillStyle = this.outputs[0] ? '#059669' : '#64748b';
        ctx.beginPath();
        ctx.arc(bbox.right, this.y - 12, 4, 0, 2 * Math.PI);
        ctx.fill();
        
        ctx.textAlign = 'left';
        ctx.fillStyle = '#1e293b';
        ctx.fillText('S', bbox.right + 8, this.y - 8);
        
        ctx.fillStyle = this.outputs[1] ? '#059669' : '#64748b';
        ctx.beginPath();
        ctx.arc(bbox.right, this.y + 12, 4, 0, 2 * Math.PI);
        ctx.fill();
        
        ctx.fillText('C', bbox.right + 8, this.y + 16);
    }
}

/**
 * Full Adder circuit implementation
 */
class FullAdder extends CircuitComponent {
    constructor(id, x = 0, y = 0) {
        super(id, 'FULL_ADDER', x, y);
        this.width = 80;
        this.height = 80;
        this.inputs = [false, false, false]; // A, B, Cin
        this.outputs = [false, false]; // Sum, Cout
    }
    
    compute() {
        const [a, b, cin] = this.inputs;
        this.outputs[0] = a !== b !== cin; // Sum = A XOR B XOR Cin
        this.outputs[1] = (a && b) || (cin && (a !== b)); // Cout = AB + Cin(A XOR B)
        return this.outputs;
    }
    
    draw(ctx) {
        const bbox = this.getBoundingBox();
        
        ctx.fillStyle = this.selected ? '#e2e8f0' : '#f8fafc';
        ctx.strokeStyle = this.selected ? '#2563eb' : '#64748b';
        ctx.lineWidth = this.selected ? 2 : 1;
        
        ctx.beginPath();
        ctx.roundRect(bbox.left, bbox.top, this.width, this.height, 8);
        ctx.fill();
        ctx.stroke();
        
        ctx.fillStyle = '#1e293b';
        ctx.font = 'bold 12px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('FULL', this.x, this.y - 5);
        ctx.fillText('ADDER', this.x, this.y + 8);
        
        this.drawFullAdderPins(ctx);
    }
    
    drawFullAdderPins(ctx) {
        const bbox = this.getBoundingBox();
        
        // Input pins
        const inputPositions = [-20, 0, 20];
        const inputLabels = ['A', 'B', 'Cin'];
        
        inputPositions.forEach((offset, i) => {
            ctx.fillStyle = this.inputs[i] ? '#059669' : '#64748b';
            ctx.beginPath();
            ctx.arc(bbox.left, this.y + offset, 4, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.fillStyle = '#1e293b';
            ctx.font = '10px monospace';
            ctx.textAlign = 'right';
            ctx.fillText(inputLabels[i], bbox.left - 8, this.y + offset + 4);
        });
        
        // Output pins
        const outputPositions = [-12, 12];
        const outputLabels = ['S', 'Cout'];
        
        outputPositions.forEach((offset, i) => {
            ctx.fillStyle = this.outputs[i] ? '#059669' : '#64748b';
            ctx.beginPath();
            ctx.arc(bbox.right, this.y + offset, 4, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.fillStyle = '#1e293b';
            ctx.textAlign = 'left';
            ctx.fillText(outputLabels[i], bbox.right + 8, this.y + offset + 4);
        });
    }
}

/**
 * 4:1 Multiplexer implementation
 */
class Multiplexer4to1 extends CircuitComponent {
    constructor(id, x = 0, y = 0) {
        super(id, 'MUX_4TO1', x, y);
        this.width = 80;
        this.height = 100;
        this.dataInputs = [false, false, false, false]; // D0, D1, D2, D3
        this.selectInputs = [false, false]; // S0, S1
        this.output = false;
    }
    
    compute() {
        const selectValue = this.selectInputs[1] * 2 + this.selectInputs[0];
        this.output = this.dataInputs[selectValue];
        return this.output;
    }
    
    draw(ctx) {
        const bbox = this.getBoundingBox();
        
        // Draw trapezoid shape typical of MUX symbol
        ctx.fillStyle = this.selected ? '#e2e8f0' : '#f8fafc';
        ctx.strokeStyle = this.selected ? '#2563eb' : '#64748b';
        ctx.lineWidth = this.selected ? 2 : 1;
        
        ctx.beginPath();
        ctx.moveTo(bbox.left, bbox.top + 10);
        ctx.lineTo(bbox.right - 20, bbox.top);
        ctx.lineTo(bbox.right, bbox.bottom);
        ctx.lineTo(bbox.left, bbox.bottom - 10);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Label
        ctx.fillStyle = '#1e293b';
        ctx.font = 'bold 10px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('MUX', this.x, this.y - 10);
        ctx.fillText('4:1', this.x, this.y + 5);
        
        this.drawMuxPins(ctx);
    }
    
    drawMuxPins(ctx) {
        const bbox = this.getBoundingBox();
        
        // Data inputs (left side)
        const dataPositions = [-30, -10, 10, 30];
        dataPositions.forEach((offset, i) => {
            ctx.fillStyle = this.dataInputs[i] ? '#059669' : '#64748b';
            ctx.beginPath();
            ctx.arc(bbox.left, this.y + offset, 3, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.fillStyle = '#1e293b';
            ctx.font = '8px monospace';
            ctx.textAlign = 'right';
            ctx.fillText(`D${i}`, bbox.left - 5, this.y + offset + 3);
        });
        
        // Select inputs (bottom)
        const selectPositions = [-10, 10];
        selectPositions.forEach((offset, i) => {
            ctx.fillStyle = this.selectInputs[i] ? '#059669' : '#64748b';
            ctx.beginPath();
            ctx.arc(this.x + offset, bbox.bottom, 3, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.fillStyle = '#1e293b';
            ctx.textAlign = 'center';
            ctx.fillText(`S${i}`, this.x + offset, bbox.bottom + 12);
        });
        
        // Output (right side)
        ctx.fillStyle = this.output ? '#059669' : '#64748b';
        ctx.beginPath();
        ctx.arc(bbox.right, this.y, 4, 0, 2 * Math.PI);
        ctx.fill();
        
        ctx.fillStyle = '#1e293b';
        ctx.textAlign = 'left';
        ctx.fillText('Y', bbox.right + 8, this.y + 4);
    }
}

/* ===== CIRCUIT TEMPLATES AND PRESETS ===== */

/**
 * Pre-built circuit configurations
 */
class CircuitTemplates {
    static halfAdderCircuit(simulator) {
        simulator.clear();
        
        // Add components
        const inputA = simulator.addComponent('INPUT', 'input_a', 50, 80, { label: 'A' });
        const inputB = simulator.addComponent('INPUT', 'input_b', 50, 140, { label: 'B' });
        const xorGate = simulator.addComponent('XOR', 'xor_1', 200, 100);
        const andGate = simulator.addComponent('AND', 'and_1', 200, 160);
        const sumOutput = simulator.addComponent('OUTPUT', 'sum_out', 350, 100, { label: 'SUM' });
        const carryOutput = simulator.addComponent('OUTPUT', 'carry_out', 350, 160, { label: 'CARRY' });
        
        // Connect components
        simulator.connectComponents('input_a', 0, 'xor_1', 0);
        simulator.connectComponents('input_b', 0, 'xor_1', 1);
        simulator.connectComponents('input_a', 0, 'and_1', 0);
        simulator.connectComponents('input_b', 0, 'and_1', 1);
        simulator.connectComponents('xor_1', 0, 'sum_out', 0);
        simulator.connectComponents('and_1', 0, 'carry_out', 0);
        
        simulator.simulate();
        simulator.render();
        
        return {
            inputs: { A: inputA, B: inputB },
            outputs: { SUM: sumOutput, CARRY: carryOutput }
        };
    }
    
    static fullAdderCircuit(simulator) {
        simulator.clear();
        
        // This would be more complex, implementing full adder with gates
        // For brevity, using the FullAdder component directly
        const inputA = simulator.addComponent('INPUT', 'input_a', 50, 60, { label: 'A' });
        const inputB = simulator.addComponent('INPUT', 'input_b', 50, 100, { label: 'B' });
        const inputCin = simulator.addComponent('INPUT', 'input_cin', 50, 140, { label: 'Cin' });
        const fullAdder = simulator.addComponent('FULL_ADDER', 'fa_1', 200, 100);
        const sumOutput = simulator.addComponent('OUTPUT', 'sum_out', 350, 80, { label: 'SUM' });
        const carryOutput = simulator.addComponent('OUTPUT', 'carry_out', 350, 120, { label: 'Cout' });
        
        // Note: This would need connection logic for the FullAdder component
        
        return {
            inputs: { A: inputA, B: inputB, Cin: inputCin },
            outputs: { SUM: sumOutput, CARRY: carryOutput }
        };
    }
    
    static mux2to1Circuit(simulator) {
        simulator.clear();
        
        const inputD0 = simulator.addComponent('INPUT', 'input_d0', 50, 80, { label: 'D0' });
        const inputD1 = simulator.addComponent('INPUT', 'input_d1', 50, 140, { label: 'D1' });
        const inputS = simulator.addComponent('INPUT', 'input_s', 150, 200, { label: 'S' });
        
        // Build 2:1 MUX using gates
        const notGate = simulator.addComponent('NOT', 'not_s', 200, 200);
        const and1 = simulator.addComponent('AND', 'and_1', 280, 90);
        const and2 = simulator.addComponent('AND', 'and_2', 280, 150);
        const orGate = simulator.addComponent('OR', 'or_1', 380, 120);
        const output = simulator.addComponent('OUTPUT', 'output_y', 480, 120, { label: 'Y' });
        
        // Connect the MUX logic
        simulator.connectComponents('input_s', 0, 'not_s', 0);
        simulator.connectComponents('input_d0', 0, 'and_1', 0);
        simulator.connectComponents('not_s', 0, 'and_1', 1);
        simulator.connectComponents('input_d1', 0, 'and_2', 0);
        simulator.connectComponents('input_s', 0, 'and_2', 1);
        simulator.connectComponents('and_1', 0, 'or_1', 0);
        simulator.connectComponents('and_2', 0, 'or_1', 1);
        simulator.connectComponents('or_1', 0, 'output_y', 0);
        
        simulator.simulate();
        simulator.render();
        
        return {
            inputs: { D0: inputD0, D1: inputD1, S: inputS },
            outputs: { Y: output }
        };
    }
}

/* ===== EXPORT FOR MODULE USAGE ===== */
window.CircuitSimulator = {
    CircuitSimulator,
    CircuitComponent,
    CircuitConnection,
    ANDGate,
    ORGate,
    XORGate,
    NOTGate,
    InputComponent,
    OutputComponent,
    HalfAdder,
    FullAdder,
    Multiplexer4to1,
    TruthTableGenerator,
    CircuitTemplates
};

// Auto-initialize canvas if present
document.addEventListener('DOMContentLoaded', () => {
    const canvases = document.querySelectorAll('canvas[data-circuit-simulator]');
    canvases.forEach(canvas => {
        const options = {
            enableAnimation: canvas.dataset.enableAnimation !== 'false',
            showGrid: canvas.dataset.showGrid === 'true',
            allowDrag: canvas.dataset.allowDrag !== 'false'
        };
        
        const simulator = new CircuitSimulator(canvas.id, options);
        
        // Store reference for external access
        canvas._circuitSimulator = simulator;
    });
});

// Export for ES6 modules if supported
if (typeof module !== 'undefined' && module.exports) {
    module.exports = window.CircuitSimulator;
}/**
 * CSC210 Circuit Simulation Library
 * Version: 1.0.0
 * 
 * This library provides interactive circuit simulation capabilities
 * for all CSC210 learning modules, including logic gates, truth tables,
 * and visual circuit representations.
 */

/* ===== BASE CLASSES ===== */

/**
 * Base class for all circuit components
 */
class CircuitComponent {
    constructor(id, type, x = 0, y = 0) {
        this.id = id;
        this.type = type;
        this.x = x;
        this.y = y;
        this.inputs = [];
        this.outputs = [];
        this.selected = false;
        this.width = 60;
        this.height = 40;
    }
    
    addInput(input) {
        this.inputs.push(input);
    }
    
    addOutput(output) {
        this.outputs.push(output);
    }
    
    getBoundingBox() {
        return {
            left: this.x - this.width / 2,
            right: this.x + this.width / 2,
            top: this.y - this.height / 2,
            bottom: this.y + this.height / 2
        };
    }
    
    containsPoint(x, y) {
        const bbox = this.getBoundingBox();
        return x >= bbox.left && x <= bbox.right && y >= bbox.top && y <= bbox.bottom;
    }
    
    // Abstract methods to be implemented by subclasses
    compute() {
        throw new Error('compute() method must be implemented by subclass');
    }
    
    draw(ctx) {
        throw new Error('draw() method must be implemented by subclass');
    }
}

/**
 * Connection between circuit components
 */
class CircuitConnection {
    constructor(fromComponent, fromOutput, toComponent, toInput) {
        this.from = fromComponent;
        this.fromOutput = fromOutput;
        this.to = toComponent;
        this.toInput = toInput;
        this.value = false;
        this.animated = false;
    }
    
    draw(ctx, animated = false) {
        const fromPos = this.getOutputPosition();
        const toPos = this.getInputPosition();
        
        ctx.strokeStyle = this.value ? '#059669' : '#64748b';
        ctx.lineWidth = this.value && animated ? 3 : 2;
        ctx.beginPath();
        
        // Draw curved connection line
        const controlPoint1X = fromPos.x + (toPos.x - fromPos.x) * 0.5;
        const controlPoint1Y = fromPos.y;
        const controlPoint2X = fromPos.x + (toPos.

/* ===== MODULE-SPECIFIC IMPLEMENTATIONS ===== */

// Half-Adder Simulator
class HalfAdderSimulator {
    constructor() {
        this.inputA = document.getElementById('ha-input-a');
        this.inputB = document.getElementById('ha-input-b');
        this.setupEventListeners();
        this.calculate();
    }
    
    setupEventListeners() {
        this.inputA.addEventListener('change', () => this.calculate());
        this.inputB.addEventListener('change', () => this.calculate());
    }
    
    calculate() {
        const a = this.inputA.checked;
        const b = this.inputB.checked;
        
        const sum = a !== b; // XOR
        const carry = a && b; // AND
        
        this.updateDisplay(sum, carry);
        this.highlightTruthTableRow(a, b);
        this.updateLogisimDiagram(a, b, sum, carry);
    }
    
    updateDisplay(sum, carry) {
        document.getElementById('ha-sum').textContent = sum ? '1' : '0';
        document.getElementById('ha-carry').textContent = carry ? '1' : '0';
    }
    
    updateLogisimDiagram(a, b, sum, carry) {
        // Update input pins
        const pinA = document.getElementById('ha-input-pin-a');
        const pinB = document.getElementById('ha-input-pin-b');
        const pinSum = document.getElementById('ha-sum-pin');
        const pinCarry = document.getElementById('ha-carry-pin');
        
        if (pinA) {
            pinA.classList.toggle('input-pin-high', a);
            pinA.classList.toggle('input-pin-low', !a);
        }
        
        if (pinB) {
            pinB.classList.toggle('input-pin-high', b);
            pinB.classList.toggle('input-pin-low', !b);
        }
        
        if (pinSum) {
            pinSum.classList.toggle('output-pin-high', sum);
            pinSum.classList.toggle('output-pin-low', !sum);
        }
        
        if (pinCarry) {
            pinCarry.classList.toggle('output-pin-high', carry);
            pinCarry.classList.toggle('output-pin-low', !carry);
        }
        
        // Update signal lines and gates
        const diagram = document.getElementById('ha-logisim-diagram');
        if (diagram) {
            const lines = diagram.querySelectorAll('line');
            const xorGate = diagram.getElementById('ha-xor-gate');
            const andGate = diagram.getElementById('ha-and-gate');
            
            // Reset all signal states
            lines.forEach(line => {
                line.classList.remove('signal-high', 'signal-low');
                line.classList.add(this.getSignalClass(line, a, b, sum, carry));
            });
            
            // Highlight active gates
            if (xorGate) {
                xorGate.classList.toggle('gate-active', a || b);
            }
            
            if (andGate) {
                andGate.classList.toggle('gate-active', a && b);
            }
        }
    }
    
    getSignalClass(line, a, b, sum, carry) {
        // Determine signal state based on line position
        // This would need to be enhanced with proper line identification
        return 'signal-low'; // Default fallback
    }
    
    highlightTruthTableRow(a, b) {
        const table = document.getElementById('ha-truth-table');
        if (!table) return;
        
        const rows = table.querySelectorAll('tbody tr');
        
        // Remove existing highlights
        rows.forEach(row => row.classList.remove('active-row'));
        
        // Find and highlight matching row
        const inputPattern = `${a ? 1 : 0},${b ? 1 : 0}`;
        const matchingRow = Array.from(rows).find(row => 
            row.dataset.inputs === inputPattern
        );
        
        if (matchingRow) {
            matchingRow.classList.add('active-row');
            matchingRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }
}

// Full-Adder Simulator
class FullAdderSimulator {
    constructor() {
        this.inputA = document.getElementById('fa-input-a');
        this.inputB = document.getElementById('fa-input-b');
        this.inputCin = document.getElementById('fa-input-cin');
        this.setupEventListeners();
        this.calculate();
    }
    
    setupEventListeners() {
        this.inputA.addEventListener('change', () => this.calculate());
        this.inputB.addEventListener('change', () => this.calculate());
        this.inputCin.addEventListener('change', () => this.calculate());
    }
    
    calculate() {
        const a = this.inputA.checked;
        const b = this.inputB.checked;
        const cin = this.inputCin.checked;
        
        // Full-adder logic
        const sum = a !== b !== cin; // A XOR B XOR Cin
        const cout = (a && b) || (cin && (a !== b)); // AB + Cin(A XOR B)
        
        this.updateDisplay(sum, cout);
        this.highlightTruthTableRow(a, b, cin);
        this.updateLogisimDiagram(a, b, cin, sum, cout);
    }
    
    updateDisplay(sum, cout) {
        document.getElementById('fa-sum').textContent = sum ? '1' : '0';
        document.getElementById('fa-carry').textContent = cout ? '1' : '0';
    }
    
    updateLogisimDiagram(a, b, cin, sum, cout) {
        // Update input pins
        const pinA = document.getElementById('fa-input-pin-a');
        const pinB = document.getElementById('fa-input-pin-b');
        const pinCin = document.getElementById('fa-input-pin-cin');
        const pinSum = document.getElementById('fa-sum-pin');
        const pinCout = document.getElementById('fa-cout-pin');
        
        if (pinA) {
            pinA.classList.toggle('input-pin-high', a);
            pinA.classList.toggle('input-pin-low', !a);
        }
        
        if (pinB) {
            pinB.classList.toggle('input-pin-high', b);
            pinB.classList.toggle('input-pin-low', !b);
        }
        
        if (pinCin) {
            pinCin.classList.toggle('input-pin-high', cin);
            pinCin.classList.toggle('input-pin-low', !cin);
        }
        
        if (pinSum) {
            pinSum.classList.toggle('output-pin-high', sum);
            pinSum.classList.toggle('output-pin-low', !sum);
        }
        
        if (pinCout) {
            pinCout.classList.toggle('output-pin-high', cout);
            pinCout.classList.toggle('output-pin-low', !cout);
        }
        
        // Update half-adder blocks based on internal logic
        const diagram = document.getElementById('fa-logisim-diagram');
        if (diagram) {
            const ha1 = diagram.getElementById('fa-half-adder-1');
            const ha2 = diagram.getElementById('fa-half-adder-2');
            const orGate = diagram.getElementById('fa-or-gate');
            
            // Calculate intermediate values
            const s1 = a !== b; // First half-adder sum
            const c1 = a && b;  // First half-adder carry
            const c2 = cin && s1; // Second half-adder carry
            
            if (ha1) {
                ha1.classList.toggle('gate-active', a || b);
            }
            
            if (ha2) {
                ha2.classList.toggle('gate-active', cin || s1);
            }
            
            if (orGate) {
                orGate.classList.toggle('gate-active', c1 || c2);
            }
        }
    }
    
    highlightTruthTableRow(a, b, cin) {
        const table = document.getElementById('fa-truth-table');
        if (!table) return;
        
        const rows = table.querySelectorAll('tbody tr');
        
        // Remove existing highlights
        rows.forEach(row => row.classList.remove('active-row'));
        
        // Find and highlight matching row
        const inputPattern = `${a ? 1 : 0},${b ? 1 : 0},${cin ? 1 : 0}`;
        const matchingRow = Array.from(rows).find(row => 
            row.dataset.inputs === inputPattern
        );
        
        if (matchingRow) {
            matchingRow.classList.add('active-row');
            matchingRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }
}

// 4-Bit Ripple-Carry Adder Simulator
class RippleCarryAdderSimulator {
    constructor() {
        this.inputsA = [
            document.getElementById('rc-a0'),
            document.getElementById('rc-a1'),
            document.getElementById('rc-a2'),
            document.getElementById('rc-a3')
        ];
        this.inputsB = [
            document.getElementById('rc-b0'),
            document.getElementById('rc-b1'),
            document.getElementById('rc-b2'),
            document.getElementById('rc-b3')
        ];
        this.carryIn = document.getElementById('rc-carry-in');
        this.setupEventListeners();
        this.calculate();
    }
    
    setupEventListeners() {
        [...this.inputsA, ...this.inputsB, this.carryIn].forEach(input => {
            if (input) {
                input.addEventListener('change', () => this.calculate());
            }
        });
    }
    
    calculate() {
        const aValues = this.inputsA.map(input => input ? input.checked : false);
        const bValues = this.inputsB.map(input => input ? input.checked : false);
        let carryIn = this.carryIn ? this.carryIn.checked : false;
        
        const sums = [];
        const carries = [carryIn]; // carries[0] is Cin, carries[1] is C0, etc.
        
        // Calculate each bit position
        for (let i = 0; i < 4; i++) {
            const a = aValues[i];
            const b = bValues[i];
            const cin = carries[i];
            
            // Full-adder logic for this bit
            const sum = a !== b !== cin;
            const cout = (a && b) || (cin && (a !== b));
            
            sums[i] = sum;
            carries[i + 1] = cout;
        }
        
        const carryOut = carries[4]; // Final carry out
        
        this.updateDisplay(sums, carryOut);
        this.updateLogisimDiagram(aValues, bValues, carryIn, sums, carries);
    }
    
    updateDisplay(sums, carryOut) {
        // Convert to binary string (MSB first for display)
        const binaryResult = [sums[3], sums[2], sums[1], sums[0]].map(s => s ? '1' : '0').join('');
        const decimalResult = parseInt(binaryResult, 2);
        
        document.getElementById('rc-sum-binary').textContent = binaryResult;
        document.getElementById('rc-sum-decimal').textContent = decimalResult.toString();
        document.getElementById('rc-carry-out').textContent = carryOut ? '1' : '0';
        
        // Update result display in diagram
        const resultDisplay = document.getElementById('rc-result-display');
        if (resultDisplay) {
            resultDisplay.textContent = `${binaryResult} (${decimalResult})`;
        }
    }
    
    updateLogisimDiagram(aValues, bValues, carryIn, sums, carries) {
        // Update input pins
        const inputPins = [
            'rc-a0-pin', 'rc-a1-pin', 'rc-a2-pin', 'rc-a3-pin',
            'rc-b0-pin', 'rc-b1-pin', 'rc-b2-pin', 'rc-b3-pin'
        ];
        
        const allInputs = [...aValues, ...bValues];
        
        inputPins.forEach((pinId, index) => {
            const pin = document.getElementById(pinId);
            if (pin) {
                const isHigh = allInputs[index];
                pin.classList.toggle('input-pin-high', isHigh);
                pin.classList.toggle('input-pin-low', !isHigh);
            }
        });
        
        // Update carry input pin
        const cinPin = document.getElementById('rc-cin-pin');
        if (cinPin) {
            cinPin.classList.toggle('input-pin-high', carryIn);
            cinPin.classList.toggle('input-pin-low', !carryIn);
        }
        
        // Update sum output pins
        const sumPins = ['rc-s0-pin', 'rc-s1-pin', 'rc-s2-pin', 'rc-s3-pin'];
        sumPins.forEach((pinId, index) => {
            const pin = document.getElementById(pinId);
            if (pin) {
                pin.classList.toggle('output-pin-high', sums[index]);
                pin.classList.toggle('output-pin-low', !sums[index]);
            }
        });
        
        // Update carry output pin
        const coutPin = document.getElementById('rc-cout-pin');
        if (coutPin) {
            coutPin.classList.toggle('output-pin-high', carries[4]);
            coutPin.classList.toggle('output-pin-low', !carries[4]);
        }
        
        // Update full-adder blocks
        const faBlocks = ['rc-fa0', 'rc-fa1', 'rc-fa2', 'rc-fa3'];
        faBlocks.forEach((faId, index) => {
            const fa = document.getElementById(faId);
            if (fa) {
                const isActive = aValues[index] || bValues[index] || carries[index];
                fa.classList.toggle('gate-active', isActive);
            }
        });
        
        // Animate carry chain
        this.animateCarryChain(carries);
    }
    
    animateCarryChain(carries) {
        const diagram = document.getElementById('rc-logisim-diagram');
        if (!diagram) return;
        
        // Find carry chain lines and highlight active ones
        const carryLines = diagram.querySelectorAll('line[stroke="#f39c12"]');
        
        carryLines.forEach((line, index) => {
            // Determine if this carry line should be active
            const carryIndex = Math.floor(index / 2);
            const isActive = carries[carryIndex + 1]; // carries[1] through carries[4]
            
            line.classList.toggle('carry-chain-active', isActive);
            line.classList.toggle('signal-animated', isActive);
        });
    }
}

// Quiz Data for Arithmetic Circuits
const quizData = [
    {
        question: "What are the outputs when A=1 and B=1 in a half-adder?",
        options: [
            "Sum=0, Carry=1",
            "Sum=1, Carry=0", 
            "Sum=1, Carry=1",
            "Sum=0, Carry=0"
        ],
        correct: 0,
        explanation: "In a half-adder, when both inputs are 1: Sum = A ⊕ B = 1 ⊕ 1 = 0, and Carry = A • B = 1 • 1 = 1"
    },
    {
        question: "What is the Boolean expression for the Sum output of a full-adder?",
        options: [
            "A • B • Cin",
            "A + B + Cin",
            "A ⊕ B ⊕ Cin",
            "A • B + Cin"
        ],
        correct: 2,
        explanation: "The Sum output of a full-adder uses XOR operations: Sum = A ⊕ B ⊕ Cin"
    },
    {
        question: "In a 4-bit ripple-carry adder, how many gate delays are in the critical path?",
        options: [
            "2 gate delays",
            "4 gate delays",
            "6 gate delays",
            "8 gate delays"
        ],
        correct: 1,
        explanation: "The critical path goes through all 4 carry stages, with each full-adder contributing 1 gate delay to the carry chain."
    },
    {
        question: "What is the main limitation of ripple-carry adders?",
        options: [
            "They consume too much power",
            "They are too complex to build",
            "Carry propagation causes timing delays",
            "They can only add positive numbers"
        ],
        correct: 2,
        explanation: "Ripple-carry adders have timing limitations because each carry must propagate through all stages before the final result is valid."
    },
    {
        question: "If A=1011 and B=0110 are added in a 4-bit adder with Cin=1, what is the result?",
        options: [
            "10010 (binary), 18 (decimal)",
            "10001 (binary), 17 (decimal)",
            "01111 (binary), 15 (decimal)",
            "10000 (binary), 16 (decimal)"
        ],
        correct: 0,
        explanation: "1011 + 0110 + 1 = 10010 in binary. Converting: 11 + 6 + 1 = 18 in decimal."
    },
    {
        question: "Which gate type is used for the Sum output in a half-adder?",
        options: [
            "AND gate",
            "OR gate", 
            "XOR gate",
            "NAND gate"
        ],
        correct: 2,
        explanation: "The Sum output uses an XOR gate because Sum = A ⊕ B, which produces 1 only when inputs differ."
    },
    {
        question: "How many full-adders are needed to build a 4-bit ripple-carry adder?",
        options: [
            "3 full-adders",
            "4 full-adders",
            "5 full-adders",
            "8 full-adders"
        ],
        correct: 1,
        explanation: "A 4-bit ripple-carry adder requires exactly 4 full-adders, one for each bit position."
    }
];

// Module initialization variables
let progressTracker;
let halfAdder;
let fullAdder; 
let rippleCarryAdder;
let quizManager;

// Module initialization function
function initializeArithmeticModule() {
    try {
        // Initialize progress tracking
        progressTracker = new ModuleUtils.ProgressTracker(window.MODULE_ID, [
            'half-adder',
            'full-adder', 
            'ripple-carry',
            'assessment'
        ]);
        window.progressTracker = progressTracker;

        // Initialize simulators
        halfAdder = new HalfAdderSimulator();
        fullAdder = new FullAdderSimulator();
        rippleCarryAdder = new RippleCarryAdderSimulator();
        
        // Initialize quiz
        quizManager = new ModuleUtils.QuizManager(quizData, 86); // Need 6/7 correct
        window.quizManager = quizManager;
        
        // Set up progress tracking
        setupProgressTracking();
        
        // Mark initial progress
        progressTracker.updateSectionProgress(0, 10);
        
        console.log('Arithmetic Circuits module initialized successfully');
        
    } catch (error) {
        console.error('Error initializing module:', error);
        if (window.errorHandler) {
            window.errorHandler.handleError(error, { section: 'initialization' });
        }
        showErrorMessage('Module failed to initialize. Please refresh the page.');
    }
}

// Progress tracking setup
function setupProgressTracking() {
    // Track half-adder interactions
    const haInputs = [
        document.getElementById('ha-input-a'),
        document.getElementById('ha-input-b')
    ];
    
    let haInteractions = 0;
    haInputs.forEach(input => {
        if (input) {
            input.addEventListener('change', () => {
                haInteractions++;
                if (haInteractions >= 3) {
                    progressTracker.updateSectionProgress(0, 60);
                }
                if (haInteractions >= 6) {
                    progressTracker.completeSection(0);
                }
            });
        }
    });
    
    // Track full-adder interactions
    const faInputs = [
        document.getElementById('fa-input-a'),
        document.getElementById('fa-input-b'),
        document.getElementById('fa-input-cin')
    ];
    
    let faInteractions = 0;
    faInputs.forEach(input => {
        if (input) {
            input.addEventListener('change', () => {
                faInteractions++;
                if (faInteractions >= 4) {
                    progressTracker.updateSectionProgress(1, 60);
                }
                if (faInteractions >= 8) {
                    progressTracker.completeSection(1);
                }
            });
        }
    });
    
    // Track ripple-carry interactions
    const rcInputs = [
        ...document.querySelectorAll('[id^="rc-a"]'),
        ...document.querySelectorAll('[id^="rc-b"]'),
        document.getElementById('rc-carry-in')
    ].filter(input => input !== null);
    
    let rcInteractions = 0;
    rcInputs.forEach(input => {
        if (input) {
            input.addEventListener('change', () => {
                rcInteractions++;
                if (rcInteractions >= 5) {
                    progressTracker.updateSectionProgress(2, 60);
                }
                if (rcInteractions >= 10) {
                    progressTracker.completeSection(2);
                }
            });
        }
    });
    
    // Track quiz completion
    if (quizManager) {
        // Quiz completion will be tracked by the QuizManager itself
        // When quiz passes, it will automatically mark section 3 complete
    }
}

// Error display function
function showErrorMessage(message) {
    const errorDiv = document.createElement('div');
    errorDiv.className = 'card';
    errorDiv.style.backgroundColor = '#fee2e2';
    errorDiv.style.borderColor = '#dc2626';
    errorDiv.style.margin = '20px 0';
    errorDiv.innerHTML = `
        <h3 style="color: #dc2626; margin: 0 0 10px 0;">⚠️ Error</h3>
        <p style="margin: 0 0 15px 0;">${message}</p>
        <button class="btn btn-secondary btn-small" onclick="this.parentElement.remove()">
            Dismiss
        </button>
    `;
    
    const container = document.querySelector('.module-container');
    if (container) {
        const firstSection = container.querySelector('.section');
        if (firstSection) {
            container.insertBefore(errorDiv, firstSection);
        } else {
            container.appendChild(errorDiv);
        }
    }
}

// Binary conversion utilities specific to arithmetic operations
const ArithmeticUtils = {
    // Convert decimal to binary with specified bit width
    decimalToBinary(decimal, bits = 4) {
        if (decimal < 0 || decimal >= Math.pow(2, bits)) {
            throw new Error(`Value ${decimal} cannot be represented in ${bits} bits`);
        }
        return decimal.toString(2).padStart(bits, '0');
    },
    
    // Convert binary string to decimal
    binaryToDecimal(binary) {
        return parseInt(binary, 2);
    },
    
    // Add two binary numbers (as strings) and return result with carry
    addBinary(a, b, carryIn = false) {
        const maxLength = Math.max(a.length, b.length);
        const paddedA = a.padStart(maxLength, '0');
        const paddedB = b.padStart(maxLength, '0');
        
        let result = '';
        let carry = carryIn;
        
        for (let i = maxLength - 1; i >= 0; i--) {
            const bitA = paddedA[i] === '1';
            const bitB = paddedB[i] === '1';
            
            const sum = bitA !== bitB !== carry; // XOR
            const newCarry = (bitA && bitB) || (carry && (bitA !== bitB)); // Carry logic
            
            result = (sum ? '1' : '0') + result;
            carry = newCarry;
        }
        
        return { result, carry };
    },
    
    // Validate binary input
    isValidBinary(input, maxBits = 4) {
        const binaryRegex = new RegExp(`^[01]{1,${maxBits}}/* ===== MODULE-SPECIFIC IMPLEMENTATIONS ===== */

// Half-Adder Simulator
class HalfAdderSimulator {
    constructor() {
        this.inputA = document.getElementById('ha-input-a');
        this.inputB = document.getElementById('ha-input-b');
        this.setupEventListeners();
        this.calculate();
    }
    
    setupEventListeners() {
        this.inputA.addEventListener('change', () => this.calculate());
        this.inputB.addEventListener('change', () => this.calculate());
    }
    
    calculate() {
        const a = this.inputA.checked;
        const b = this.inputB.checked;
        
        const sum = a !== b; // XOR
        const carry = a && b; // AND
        
        this.updateDisplay(sum, carry);
        this.highlightTruthTableRow(a, b);
        this.updateLogisimDiagram(a, b, sum, carry);
    }
    
    updateDisplay(sum, carry) {
        document.getElementById('ha-sum').textContent = sum ? '1' : '0';
        document.getElementById('ha-carry').textContent = carry ? '1' : '0';
    }
    
    updateLogisimDiagram(a, b, sum, carry) {
        // Update input pins
        const pinA = document.getElementById('ha-input-pin-a');
        const pinB = document.getElementById('ha-input-pin-b');
        const pinSum = document.getElementById('ha-sum-pin');
        const pinCarry = document.getElementById('ha-carry-pin');
        
        if (pinA) {
            pinA.classList.toggle('input-pin-high', a);
            pinA.classList.toggle('input-pin-low', !a);
        }
        
        if (pinB) {
            pinB.classList.toggle('input-pin-high', b);
            pinB.classList.toggle('input-pin-low', !b);
        }
        
        if (pinSum) {
            pinSum.classList.toggle('output-pin-high', sum);
            pinSum.classList.toggle('output-pin-low', !sum);
        }
        
        if (pinCarry) {
            pinCarry.classList.toggle('output-pin-high', carry);
            pinCarry.classList.toggle('output-pin-low', !carry);
        }
        
        // Update signal lines and gates
        const diagram = document.getElementById('ha-logisim-diagram');
        if (diagram) {
            const lines = diagram.querySelectorAll('line');
            const xorGate = diagram.getElementById('ha-xor-gate');
            const andGate = diagram.getElementById('ha-and-gate');
            
            // Reset all signal states
            lines.forEach(line => {
                line.classList.remove('signal-high', 'signal-low');
                line.classList.add(this.getSignalClass(line, a, b, sum, carry));
            });
            
            // Highlight active gates
            if (xorGate) {
                xorGate.classList.toggle('gate-active', a || b);
            }
            
            if (andGate) {
                andGate.classList.toggle('gate-active', a && b);
            }
        }
    }
    
    getSignalClass(line, a, b, sum, carry) {
        // Determine signal state based on line position
        // This would need to be enhanced with proper line identification
        return 'signal-low'; // Default fallback
    }
    
    highlightTruthTableRow(a, b) {
        const table = document.getElementById('ha-truth-table');
        if (!table) return;
        
        const rows = table.querySelectorAll('tbody tr');
        
        // Remove existing highlights
        rows.forEach(row => row.classList.remove('active-row'));
        
        // Find and highlight matching row
        const inputPattern = `${a ? 1 : 0},${b ? 1 : 0}`;
        const matchingRow = Array.from(rows).find(row => 
            row.dataset.inputs === inputPattern
        );
        
        if (matchingRow) {
            matchingRow.classList.add('active-row');
            matchingRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }
}

// Full-Adder Simulator
class FullAdderSimulator {
    constructor() {
        this.inputA = document.getElementById('fa-input-a');
        this.inputB = document.getElementById('fa-input-b');
        this.inputCin = document.getElementById('fa-input-cin');
        this.setupEventListeners();
        this.calculate();
    }
    
    setupEventListeners() {
        this.inputA.addEventListener('change', () => this.calculate());
        this.inputB.addEventListener('change', () => this.calculate());
        this.inputCin.addEventListener('change', () => this.calculate());
    }
    
    calculate() {
        const a = this.inputA.checked;
        const b = this.inputB.checked;
        const cin = this.inputCin.checked;
        
        // Full-adder logic
        const sum = a !== b !== cin; // A XOR B XOR Cin
        const cout = (a && b) || (cin && (a !== b)); // AB + Cin(A XOR B)
        
        this.updateDisplay(sum, cout);
        this.highlightTruthTableRow(a, b, cin);
        this.updateLogisimDiagram(a, b, cin, sum, cout);
    }
    
    updateDisplay(sum, cout) {
        document.getElementById('fa-sum').textContent = sum ? '1' : '0';
        document.getElementById('fa-carry').textContent = cout ? '1' : '0';
    }
    
    updateLogisimDiagram(a, b, cin, sum, cout) {
        // Update input pins
        const pinA = document.getElementById('fa-input-pin-a');
        const pinB = document.getElementById('fa-input-pin-b');
        const pinCin = document.getElementById('fa-input-pin-cin');
        const pinSum = document.getElementById('fa-sum-pin');
        const pinCout = document.getElementById('fa-cout-pin');
        
        if (pinA) {
            pinA.classList.toggle('input-pin-high', a);
            pinA.classList.toggle('input-pin-low', !a);
        }
        
        if (pinB) {
            pinB.classList.toggle('input-pin-high', b);
            pinB.classList.toggle('input-pin-low', !b);
        }
        
        if (pinCin) {
            pinCin.classList.toggle('input-pin-high', cin);
            pinCin.classList.toggle('input-pin-low', !cin);
        }
        
        if (pinSum) {
            pinSum.classList.toggle('output-pin-high', sum);
            pinSum.classList.toggle('output-pin-low', !sum);
        }
        
        if (pinCout) {
            pinCout.classList.toggle('output-pin-high', cout);
            pinCout.classList.toggle('output-pin-low', !cout);
        }
        
        // Update half-adder blocks based on internal logic
        const diagram = document.getElementById('fa-logisim-diagram');
        if (diagram) {
            const ha1 = diagram.getElementById('fa-half-adder-1');
            const ha2 = diagram.getElementById('fa-half-adder-2');
            const orGate = diagram.getElementById('fa-or-gate');
            
            // Calculate intermediate values
            const s1 = a !== b; // First half-adder sum
            const c1 = a && b;  // First half-adder carry
            const c2 = cin && s1; // Second half-adder carry
            
            if (ha1) {
                ha1.classList.toggle('gate-active', a || b);
            }
            
            if (ha2) {
                ha2.classList.toggle('gate-active', cin || s1);
            }
            
            if (orGate) {
                orGate.classList.toggle('gate-active', c1 || c2);
            }
        }
    }
    
    highlightTruthTableRow(a, b, cin) {
        const table = document.getElementById('fa-truth-table');
        if (!table) return;
        
        const rows = table.querySelectorAll('tbody tr');
        
        // Remove existing highlights
        rows.forEach(row => row.classList.remove('active-row'));
        
        // Find and highlight matching row
        const inputPattern = `${a ? 1 : 0},${b ? 1 : 0},${cin ? 1 : 0}`;
        const matchingRow = Array.from(rows).find(row => 
            row.dataset.inputs === inputPattern
        );
        
        if (matchingRow) {
            matchingRow.classList.add('active-row');
            matchingRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }
}

// 4-Bit Ripple-Carry Adder Simulator
class RippleCarryAdderSimulator {
    constructor() {
        this.inputsA = [
            document.getElementById('rc-a0'),
            document.getElementById('rc-a1'),
            document.getElementById('rc-a2'),
            document.getElementById('rc-a3')
        ];
        this.inputsB = [
            document.getElementById('rc-b0'),
            document.getElementById('rc-b1'),
            document.getElementById('rc-b2'),
            document.getElementById('rc-b3')
        ];
        this.carryIn = document.getElementById('rc-carry-in');
        this.setupEventListeners();
        this.calculate();
    }
    
    setupEventListeners() {
        [...this.inputsA, ...this.inputsB, this.carryIn].forEach(input => {
            if (input) {
                input.addEventListener('change', () => this.calculate());
            }
        });
    }
    
    calculate() {
        const aValues = this.inputsA.map(input => input ? input.checked : false);
        const bValues = this.inputsB.map(input => input ? input.checked : false);
        let carryIn = this.carryIn ? this.carryIn.checked : false;
        
        const sums = [];
        const carries = [carryIn]; // carries[0] is Cin, carries[1] is C0, etc.
        
        // Calculate each bit position
        for (let i = 0; i < 4; i++) {
            const a = aValues[i];
            const b = bValues[i];
            const cin = carries[i];
            
            // Full-adder logic for this bit
            const sum = a !== b !== cin;
            const cout = (a && b) || (cin && (a !== b));
            
            sums[i] = sum;
            carries[i + 1] = cout;
        }
        
        const carryOut = carries[4]; // Final carry out
        
        this.updateDisplay(sums, carryOut);
        this.updateLogisimDiagram(aValues, bValues, carryIn, sums, carries);
    }
    
    updateDisplay(sums, carryOut) {
        // Convert to binary string (MSB first for display)
        const binaryResult = [sums[3], sums[2], sums[1], sums[0]].map(s => s ? '1' : '0').join('');
        const decimalResult = parseInt(binaryResult, 2);
        
        document.getElementById('rc-sum-binary').textContent = binaryResult;
        document.getElementById('rc-sum-decimal').textContent = decimalResult.toString();
        document.getElementById('rc-carry-out').textContent = carryOut ? '1' : '0';
        
        // Update result display in diagram
        const resultDisplay = document.getElementById('rc-result-display');
        if (resultDisplay) {
            resultDisplay.textContent = `${binaryResult} (${decimalResult})`;
        }
    }
    
    updateLogisimDiagram(aValues, bValues, carryIn, sums, carries) {
        // Update input pins
        const inputPins = [
            'rc-a0-pin', 'rc-a1-pin', 'rc-a2-pin', 'rc-a3-pin',
            'rc-b0-pin', 'rc-b1-pin', 'rc-b2-pin', 'rc-b3-pin'
        ];
        
        const allInputs = [...aValues, ...bValues];
        
        inputPins.forEach((pinId, index) => {
            const pin = document.getElementById(pinId);
            if (pin) {
                const isHigh = allInputs[index];
                pin.classList.toggle('input-pin-high', isHigh);
                pin.classList.toggle('input-pin-low', !isHigh);
            }
        });
        
        // Update carry input pin
        const cinPin = document.getElementById('rc-cin-pin');
        if (cinPin) {
            cinPin.classList.toggle('input-pin-high', carryIn);
            cinPin.classList.toggle('input-pin-low', !carryIn);
        }
        
        // Update sum output pins
        const sumPins = ['rc-s0-pin', 'rc-s1-pin', 'rc-s2-pin', 'rc-s3-pin'];
        sumPins.forEach((pinId, index) => {
            const pin = document.getElementById(pinId);
            if (pin) {
                pin.classList.toggle('output-pin-high', sums[index]);
                pin.classList.toggle('output-pin-low', !sums[index]);
            }
        });
        
        // Update carry output pin
        const coutPin = document.getElementById('rc-cout-pin');
        if (coutPin) {
            coutPin.classList.toggle('output-pin-high', carries[4]);
            coutPin.classList.toggle('output-pin-low', !carries[4]);
        }
        
        // Update full-adder blocks
        const faBlocks = ['rc-fa0', 'rc-fa1', 'rc-fa2', 'rc-fa3'];
        faBlocks.forEach((faId, index) => {
            const fa = document.getElementById(faId);
            if (fa) {
                const isActive = aValues[index] || bValues[index] || carries[index];
                fa.classList.toggle('gate-active', isActive);
            }
        });
        
        // Animate carry chain
        this.animateCarryChain(carries);
    }
    
    animateCarryChain(carries) {
        const diagram = document.getElementById('rc-logisim-diagram');
        if (!diagram) return;
        
        // Find carry chain lines and highlight active ones
        const carryLines = diagram.querySelectorAll('line[stroke="#f39c12"]');
        
);
        return binaryRegex.test(input);
    }
};

// Module cleanup function
function cleanupArithmeticModule() {
    // Clean up event listeners and timers if needed
    if (progressTracker) {
        // Send final progress update if module was completed
        if (progressTracker.getTotalProgress() === 100) {
            progressTracker.markComplete({
                quizScore: quizManager ? quizManager.calculateScore() : 0,
                finalSection: 'assessment'
            });
        }
    }
}

// Initialize when DOM loads
document.addEventListener('DOMContentLoaded', initializeArithmeticModule);

// Handle page unload for cleanup
window.addEventListener('beforeunload', cleanupArithmeticModule);

// Export utilities for potential external use
window.ArithmeticUtils = ArithmeticUtils;

/* ===== COMPLETE MODULE INITIALIZATION SCRIPT ===== */

// This script should be placed at the end of the HTML file, after all shared utilities are loaded

// Set module ID (CRITICAL - must be first)
window.MODULE_ID = 'arithmetic';

// Enhanced quiz manager that integrates with progress tracking
class ArithmeticQuizManager extends ModuleUtils.QuizManager {
    constructor(quizData, passingScore = 86) {
        super(quizData, passingScore);
        this.moduleProgressTracker = window.progressTracker;
    }
    
    completeQuiz() {
        const result = super.completeQuiz();
        
        // Integration with progress tracker
        if (this.moduleProgressTracker && result.passed) {
            this.moduleProgressTracker.completeSection(3); // Assessment section
            this.moduleProgressTracker.markComplete({
                quizScore: result.score,
                timeSpent: this.moduleProgressTracker.getTimeSpent(),
                sectionsCompleted: ['half-adder', 'full-adder', 'ripple-carry', 'assessment']
            });
        }
        
        return result;
    }
    
    displayResults(score, passed) {
        super.displayResults(score, passed);
        
        // Add module completion notification
        if (passed && window.progressTracker) {
            const communication = new ModuleUtils.PlatformCommunication(window.MODULE_ID);
            communication.sendNotification(
                'Congratulations! You have completed the Arithmetic Circuits module.',
                'success'
            );
        }
    }
}

// Enhanced module initialization with comprehensive error handling
function initializeCompleteArithmeticModule() {
    console.log('Initializing Arithmetic Circuits Module...');
    
    try {
        // Validate that all required shared utilities are loaded
        if (!window.ModuleUtils) {
            throw new Error('ModuleUtils not found. Ensure shared utilities are loaded first.');
        }
        
        if (!window.CircuitSimulator) {
            console.warn('CircuitSimulator not found. Some advanced features may be limited.');
        }
        
        // Initialize progress tracking first
        window.progressTracker = new ModuleUtils.ProgressTracker(window.MODULE_ID, [
            'half-adder',
            'full-adder', 
            'ripple-carry',
            'assessment'
        ]);
        
        // Initialize circuit simulators
        const simulatorResults = initializeSimulators();
        
        // Initialize enhanced quiz system
        window.quizManager = new ArithmeticQuizManager(getQuizData(), 86);
        
        // Set up progress tracking with interaction monitoring
        setupComprehensiveProgressTracking();
        
        // Initialize circuit diagrams if containers exist
        initializeCircuitDiagrams();
        
        // Set up keyboard shortcuts and accessibility features
        setupAccessibilityFeatures();
        
        // Mark initial progress
        window.progressTracker.updateSectionProgress(0, 10);
        
        // Send module loaded notification
        const communication = new ModuleUtils.PlatformCommunication(window.MODULE_ID);
        communication.sendNotification('Arithmetic Circuits module loaded successfully', 'info');
        
        console.log('Arithmetic Circuits module initialized successfully');
        console.log('Simulator status:', simulatorResults);
        
        return {
            success: true,
            simulators: simulatorResults,
            progressTracker: window.progressTracker,
            quizManager: window.quizManager
        };
        
    } catch (error) {
        console.error('Failed to initialize Arithmetic Circuits module:', error);
        
        // Use error handler if available
        if (window.errorHandler) {
            window.errorHandler.handleError(error, { 
                section: 'module_initialization',
                moduleId: window.MODULE_ID
            });
        }
        
        // Show user-friendly error message
        showInitializationError(error.message);
        
        return {
            success: false,
            error: error.message
        };
    }
}

// Initialize all circuit simulators
function initializeSimulators() {
    const results = {
        halfAdder: null,
        fullAdder: null,
        rippleCarryAdder: null,
        errors: []
    };
    
    try {
        // Half-Adder Simulator
        if (document.getElementById('ha-input-a') && document.getElementById('ha-input-b')) {
            results.halfAdder = new HalfAdderSimulator();
            console.log('Half-adder simulator initialized');
        } else {
            results.errors.push('Half-adder inputs not found');
        }
    } catch (error) {
        results.errors.push(`Half-adder initialization failed: ${error.message}`);
    }
    
    try {
        // Full-Adder Simulator
        if (document.getElementById('fa-input-a') && 
            document.getElementById('fa-input-b') && 
            document.getElementById('fa-input-cin')) {
            results.fullAdder = new FullAdderSimulator();
            console.log('Full-adder simulator initialized');
        } else {
            results.errors.push('Full-adder inputs not found');
        }
    } catch (error) {
        results.errors.push(`Full-adder initialization failed: ${error.message}`);
    }
    
    try {
        // Ripple-Carry Adder Simulator
        const rcInputsExist = ['rc-a0', 'rc-a1', 'rc-a2', 'rc-a3', 
                               'rc-b0', 'rc-b1', 'rc-b2', 'rc-b3', 'rc-carry-in']
                               .every(id => document.getElementById(id));
        
        if (rcInputsExist) {
            results.rippleCarryAdder = new RippleCarryAdderSimulator();
            console.log('Ripple-carry adder simulator initialized');
        } else {
            results.errors.push('Ripple-carry adder inputs not found');
        }
    } catch (error) {
        results.errors.push(`Ripple-carry adder initialization failed: ${error.message}`);
    }
    
    // Store simulators globally for access
    window.halfAdder = results.halfAdder;
    window.fullAdder = results.fullAdder;
    window.rippleCarryAdder = results.rippleCarryAdder;
    
    return results;
}

// Initialize circuit diagram containers
function initializeCircuitDiagrams() {
    // Replace placeholder containers with actual Logisim-style diagrams
    const containers = [
        { id: 'ha-circuit-container', diagram: 'ha-logisim-diagram' },
        { id: 'fa-circuit-container', diagram: 'fa-logisim-diagram' },
        { id: 'rc-circuit-container', diagram: 'rc-logisim-diagram' }
    ];
    
    containers.forEach(({ id, diagram }) => {
        const container = document.getElementById(id);
        const diagramSvg = document.getElementById(diagram);
        
        if (container && diagramSvg) {
            // Replace placeholder content with actual diagram
            container.innerHTML = '';
            container.appendChild(diagramSvg.cloneNode(true));
            console.log(`Initialized circuit diagram for ${id}`);
        }
    });
}

// Set up comprehensive progress tracking
function setupComprehensiveProgressTracking() {
    const tracker = window.progressTracker;
    if (!tracker) return;
    
    // Half-adder progress tracking
    const haInputs = ['ha-input-a', 'ha-input-b'];
    let haInteractionCount = 0;
    const haTargetInteractions = 6;
    
    haInputs.forEach(inputId => {
        const input = document.getElementById(inputId);
        if (input) {
            input.addEventListener('change', () => {
                haInteractionCount++;
                const progress = Math.min(100, (haInteractionCount / haTargetInteractions) * 100);
                tracker.updateSectionProgress(0, progress);
                
                if (haInteractionCount >= haTargetInteractions) {
                    tracker.completeSection(0);
                }
            });
        }
    });
    
    // Full-adder progress tracking  
    const faInputs = ['fa-input-a', 'fa-input-b', 'fa-input-cin'];
    let faInteractionCount = 0;
    const faTargetInteractions = 8; // 3 inputs * ~3 interactions each
    
    faInputs.forEach(inputId => {
        const input = document.getElementById(inputId);
        if (input) {
            input.addEventListener('change', () => {
                faInteractionCount++;
                const progress = Math.min(100, (faInteractionCount / faTargetInteractions) * 100);
                tracker.updateSectionProgress(1, progress);
                
                if (faInteractionCount >= faTargetInteractions) {
                    tracker.completeSection(1);
                }
            });
        }
    });
    
    // Ripple-carry adder progress tracking
    const rcInputs = ['rc-a0', 'rc-a1', 'rc-a2', 'rc-a3', 
                      'rc-b0', 'rc-b1', 'rc-b2', 'rc-b3', 'rc-carry-in'];
    let rcInteractionCount = 0;
    const rcTargetInteractions = 12; // More complex, needs more exploration
    
    rcInputs.forEach(inputId => {
        const input = document.getElementById(inputId);
        if (input) {
            input.addEventListener('change', () => {
                rcInteractionCount++;
                const progress = Math.min(100, (rcInteractionCount / rcTargetInteractions) * 100);
                tracker.updateSectionProgress(2, progress);
                
                if (rcInteractionCount >= rcTargetInteractions) {
                    tracker.completeSection(2);
                }
            });
        }
    });
    
    console.log('Progress tracking configured for all sections');
}

// Set up accessibility features
function setupAccessibilityFeatures() {
    // Keyboard shortcuts
    document.addEventListener('keydown', (event) => {
        // Alt+1, Alt+2, Alt+3 to jump between sections
        if (event.altKey && ['1', '2', '3'].includes(event.key)) {
            event.preventDefault();
            const sectionMap = {
                '1': 'half-adder-section',
                '2': 'full-adder-section', 
                '3': 'ripple-carry-section'
            };
            
            const section = document.getElementById(sectionMap[event.key]);
            if (section) {
                section.scrollIntoView({ behavior: 'smooth' });
                section.querySelector('h2').focus();
            }
        }
        
        // Space bar to toggle focused checkboxes
        if (event.code === 'Space' && event.target.type === 'checkbox') {
            // Let default behavior handle this, but announce change
            setTimeout(() => {
                const label = event.target.nextElementSibling;
                const state = event.target.checked ? 'checked' : 'unchecked';
                ModuleUtils.Utils.accessibility.announceToScreenReader(
                    `${label ? label.textContent : 'Input'} ${state}`
                );
            }, 10);
        }
    });
    
    // Enhanced focus management for truth tables
    const truthTables = document.querySelectorAll('.truth-table');
    truthTables.forEach(table => {
        table.addEventListener('keydown', (event) => {
            if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
                event.preventDefault();
                const rows = Array.from(table.querySelectorAll('tbody tr'));
                const currentRow = event.target.closest('tr');
                const currentIndex = rows.indexOf(currentRow);
                
                let nextIndex;
                if (event.key === 'ArrowDown') {
                    nextIndex = (currentIndex + 1) % rows.length;
                } else {
                    nextIndex = currentIndex === 0 ? rows.length - 1 : currentIndex - 1;
                }
                
                if (rows[nextIndex]) {
                    rows[nextIndex].focus();
                    rows[nextIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }
        });
    });
    
    console.log('Accessibility features configured');
}

// Get quiz data
function getQuizData() {
    return [
        {
            question: "What are the outputs when A=1 and B=1 in a half-adder?",
            options: [
                "Sum=0, Carry=1",
                "Sum=1, Carry=0", 
                "Sum=1, Carry=1",
                "Sum=0, Carry=0"
            ],
            correct: 0,
            explanation: "In a half-adder, when both inputs are 1: Sum = A ⊕ B = 1 ⊕ 1 = 0, and Carry = A • B = 1 • 1 = 1"
        },
        {
            question: "What is the Boolean expression for the Sum output of a full-adder?",
            options: [
                "A • B • Cin",
                "A + B + Cin",
                "A ⊕ B ⊕ Cin",
                "A • B + Cin"
            ],
            correct: 2,
            explanation: "The Sum output of a full-adder uses XOR operations: Sum = A ⊕ B ⊕ Cin"
        },
        {
            question: "In a 4-bit ripple-carry adder, how many gate delays are in the critical path?",
            options: [
                "2 gate delays",
                "4 gate delays", 
                "6 gate delays",
                "8 gate delays"
            ],
            correct: 1,
            explanation: "The critical path goes through all 4 carry stages, with each full-adder contributing 1 gate delay to the carry chain."
        },
        {
            question: "What is the main limitation of ripple-carry adders?",
            options: [
                "They consume too much power",
                "They are too complex to build",
                "Carry propagation causes timing delays",
                "They can only add positive numbers"
            ],
            correct: 2,
            explanation: "Ripple-carry adders have timing limitations because each carry must propagate through all stages before the final result is valid."
        },
        {
            question: "If A=1011 and B=0110 are added in a 4-bit adder with Cin=1, what is the result?",
            options: [
                "10010 (binary), 18 (decimal)",
                "10001 (binary), 17 (decimal)",
                "01111 (binary), 15 (decimal)", 
                "10000 (binary), 16 (decimal)"
            ],
            correct: 0,
            explanation: "1011 + 0110 + 1 = 10010 in binary. Converting: 11 + 6 + 1 = 18 in decimal."
        },
        {
            question: "Which gate type is used for the Sum output in a half-adder?",
            options: [
                "AND gate",
                "OR gate", 
                "XOR gate",
                "NAND gate"
            ],
            correct: 2,
            explanation: "The Sum output uses an XOR gate because Sum = A ⊕ B, which produces 1 only when inputs differ."
        },
        {
            question: "How many full-adders are needed to build a 4-bit ripple-carry adder?",
            options: [
                "3 full-adders",
                "4 full-adders",
                "5 full-adders", 
                "8 full-adders"
            ],
            correct: 1,
            explanation: "A 4-bit ripple-carry adder requires exactly 4 full-adders, one for each bit position."
        }
    ];
}

// Error display for initialization failures
function showInitializationError(message) {
    const errorDiv = document.createElement('div');
    errorDiv.className = 'card';
    errorDiv.style.cssText = `
        background-color: #fee2e2;
        border-color: #dc2626;
        margin: 20px;
        padding: 20px;
        border-radius: 8px;
        border: 2px solid #dc2626;
    `;
    
    errorDiv.innerHTML = `
        <h2 style="color: #dc2626; margin: 0 0 15px 0;">⚠️ Module Initialization Failed</h2>
        <p style="margin: 0 0 15px 0; color: #7f1d1d;">${message}</p>
        <p style="margin: 0 0 20px 0; font-size: 14px; color: #991b1b;">
            This usually indicates a problem with the module setup. Please try refreshing the page, 
            or contact your instructor if the problem persists.
        </p>
        <div style="display: flex; gap: 10px;">
            <button class="btn btn-primary" onclick="window.location.reload()">
                Refresh Page
            </button>
            <button class="btn btn-secondary" onclick="this.closest('.card').remove()">
                Dismiss
            </button>
        </div>
    `;
    
    // Insert at the beginning of the page
    document.body.insertBefore(errorDiv, document.body.firstChild);
}

// Module cleanup function
function cleanupArithmeticModule() {
    console.log('Cleaning up Arithmetic Circuits module...');
    
    try {
        // Send final completion status if appropriate
        if (window.progressTracker && window.progressTracker.getTotalProgress() === 100) {
            window.progressTracker.markComplete({
                quizScore: window.quizManager ? window.quizManager.calculateScore() : 0,
                timeSpent: window.progressTracker.getTimeSpent(),
                sectionsCompleted: ['half-adder', 'full-adder', 'ripple-carry', 'assessment']
            });
        }
        
        // Clear any ongoing animations or timers
        // (Add cleanup code here if needed)
        
    } catch (error) {
        console.warn('Error during module cleanup:', error);
    }
}

// Initialize when DOM is fully loaded
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeCompleteArithmeticModule);
} else {
    // DOM already loaded
    initializeCompleteArithmeticModule();
}

// Handle page unload
window.addEventListener('beforeunload', cleanupArithmeticModule);

// Export for debugging
window.ArithmeticModule = {
    initialize: initializeCompleteArithmeticModule,
    cleanup: cleanupArithmeticModule,
    getStatus: () => ({
        progressTracker: window.progressTracker,
        simulators: {
            halfAdder: window.halfAdder,
            fullAdder: window.fullAdder, 
            rippleCarryAdder: window.rippleCarryAdder
        },
        quizManager: window.quizManager
    })
};
        </script>



        </html>
